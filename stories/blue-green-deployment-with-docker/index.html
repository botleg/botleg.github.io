<!DOCTYPE html> <html> <head> <title>Building Blue-Green Deployment with Docker</title> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="description" content="Blue-Green Deployment is a strategy to release new version of the app without downtime. The basic idea behind this technique involves using two identical pro..."> <meta name="author" content="Hanzel Jesheen"> <meta itemprop="name" content="Building Blue-Green Deployment with Docker"> <meta itemprop="description" content="Blue-Green Deployment is a strategy to release new version of the app without downtime. The basic idea behind this technique involves using two identical pro..."> <link rel="canonical" href="https://botleg.com/stories/blue-green-deployment-with-docker/"> <link rel="alternate" type="application/rss+xml" title="Botleg" href="https://botleg.com/feed" /> </head> <body> <div class="page-content"> <div class="post"> <header style="background:rgb(0, 178, 100);background-image:linear-gradient(90deg, rgb(0, 178, 100) 5%, rgb(63, 81, 181) 100%);background-image:-moz-linear-gradient(left, rgb(0, 178, 100) 5%, rgb(63, 81, 181) 100%);background-image:-webkit-linear-gradient(left, rgb(0, 178, 100) 5%, rgb(63, 81, 181) 100%);background-image:-o-linear-gradient(left, rgb(0, 178, 100) 5%, rgb(63, 81, 181) 100%);background-image:-ms-linear-gradient(left, rgb(0, 178, 100) 5%, rgb(63, 81, 181) 100%);"> <section class="site-header"> <div class="wrapper"> <a class="site-title" href="/">Botleg</a> <div id="search"> <a href="/feed/index.xml"><span class="rss-icon"> <svg viewBox="0 0 24 24" width="30px" height="30px"> <use xlink:href="/assets/images/sprites.svg#rss"></use> </svg></span> </a> <form id="searchform"> <input type="text" placeholder="search" id="searchbox"> </form> </div> </div> </section> <section class="post-header"> <div class="header-content"> <h1 class="post-title">Building Blue-Green Deployment with Docker</h1> <a class="icon gh" href="https://github.com/botleg/blue-green" target="blank"><span>View Code</span></a> </div> </section> </header> <div class="wrapper"> <section> <article class="post-content"> <p class="post-meta">Written by Hanzel Jesheen on Apr 10, 2016 | <a href="/categories/devops">devops</a> </p> <p>Blue-Green Deployment is a strategy to release new version of the app without downtime. The basic idea behind this technique involves using two identical production environments, named <code class="highlighter-rouge">Blue</code> and <code class="highlighter-rouge">Green</code>. At any time, only one of these environment is live and serving the production traffic. The other one is used to test newer version or for roll-back.</p> <p>Let us assume that the current live production environment is Blue. When the new version is ready, we can deploy it to the non-production environment - Green. None of our users can see this new version as the live environment is still Blue. We can test the new version from the Green environment now. If this version is ready for release, we switch the production environment to Green and the users can now see the new release. Now the live version in at Green and staging can be done in Blue. If there is some error with the new release in Green, it is easy to roll-back to previous version by just switching the production environment back to Blue. Only thing to note here is that the switching is seamless.</p> <p>In this article, we will build a blue-green deployment system with Dockers. We will create and control a cluster of nodes with Docker Swarm. We will build a Blue-Green deployment docker image that creates two environment, each running different versions of same test app. We will also see how to switch the live environment with out Docker image.</p> <p>The docker image for Blue-Green deployment is <a href="https://hub.docker.com/r/hanzel/blue-green/">hanzel/blue-green</a> and its code can be found <a href="https://github.com/botleg/blue-green">here</a>. Also, the docker image for the test application is <a href="https://hub.docker.com/r/hanzel/nginx-html/">hanzel/nginx-html</a> and its code can be found <a href="https://github.com/botleg/nginx-html">here</a>.</p> <h2 id="prerequisites">Prerequisites</h2> <p>We will be using <a href="https://docs.docker.com/machine/">Docker Machine</a> to create and manage remote hosts as a swarm. With Docker Machine, you can create hosts on your local machine or your cloud provider. Check <a href="https://docs.docker.com/machine/drivers/">this link</a> to see the drivers supported by Docker Machine.</p> <p>You need to have the following installed in you local computer:</p> <ul> <li><code class="highlighter-rouge">Docker</code>: version &gt;= 1.10, to support Docker Compose File version 2 and Multi-Host networking.</li> <li><code class="highlighter-rouge">Docker Machine</code>: version &gt;= 0.6</li> <li><code class="highlighter-rouge">Docker Compose</code>: version &gt;= 1.6, to support Docker Compose file version 2</li> </ul> <p>You can create the virtual hosts in you local system if you have <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> installed. For this demonstration, I will be using <a href="https://www.digitalocean.com/">DigitalOcean</a>.</p> <h2 id="creating-the-swarm">Creating the Swarm</h2> <p>The first thing we need to do is to create the Docker Swarm using Docker Machine and set it up. I have explained how to do this in my previous article, <a href="/stories/load-balancing-with-docker-swarm/">Load Balancing with Docker Swarm</a>. Follow the steps from <code class="highlighter-rouge">Initial Setup</code> to <code class="highlighter-rouge">The Swarm</code> of that article to create and setup the Swarm.</p> <p>Once the swarm is setup, you can see the hosts with <code class="highlighter-rouge">docker-machine ls</code> command. The output of this command must look something like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">NAME     ACTIVE      DRIVER         STATE     URL                          SWARM             DOCKER
consul   -           digitalocean   Running   tcp://104.236.235.185:2376                     v1.10.1
master   <span class="k">*</span> <span class="o">(</span>swarm<span class="o">)</span>   digitalocean   Running   tcp://159.203.119.37:2376    master <span class="o">(</span>master<span class="o">)</span>   v1.10.1
slave    -           digitalocean   Running   tcp://45.55.185.18:2376      master            v1.10.1 </code></pre></figure> <h2 id="test-app">Test App</h2> <p>To demonstrate blue-green deployment, we will deploy different versions of our test app. The docker image for this app is <a href="https://hub.docker.com/r/hanzel/nginx-html/">hanzel/nginx-html</a> and the code for it can be found <a href="https://github.com/botleg/nginx-html">here</a>. The docker image contains the <code class="highlighter-rouge">nginx</code> webserver that serves a static HTML page at port <code class="highlighter-rouge">80</code>.</p> <p>The HTML page contains the current version or tag of the docker image. So the image <code class="highlighter-rouge">hanzel/nginx-html:1</code> serves the HTML page with <code class="highlighter-rouge">Version 1</code>, <code class="highlighter-rouge">hanzel/nginx-html:2</code> serves the HTML page with <code class="highlighter-rouge">Version 2</code> and <code class="highlighter-rouge">hanzel/nginx-html:3</code> serves the HTML page with <code class="highlighter-rouge">Version 3</code>.</p> <h2 id="consul-template">Consul Template</h2> <p>Now, we are going to build the image that does the blue-green deployment. It uses <a href="https://www.nginx.com/">nginx</a> webserver for load balancing and <a href="https://github.com/hashicorp/consul-template">consul-template</a> to manage nginx configuration dynamically. The docker image for this app is <a href="https://hub.docker.com/r/hanzel/blue-green/">hanzel/blue-green</a> and the code for it can be found <a href="https://github.com/botleg/blue-green">here</a>.</p> <p>If the current live environment is <code class="highlighter-rouge">blue</code>, we can access that at port 80 of the container. The staging environment, <code class="highlighter-rouge">green</code> in this case, can be accessed from the port 8080 of the container. We will be able to switch the live environment anytime with just one command. If we switch the live environment to <code class="highlighter-rouge">green</code>, then we can access the live <code class="highlighter-rouge">green</code> environment at port 80 and staging <code class="highlighter-rouge">blue</code> environment at port 8080. This is how the image facilitates blue-green deployment.</p> <p>We have used the <code class="highlighter-rouge">registrator</code> image to register our running docker images to <code class="highlighter-rouge">consul</code>. Now, <code class="highlighter-rouge">consul-template</code> will read these and create custom configuration of <code class="highlighter-rouge">nginx</code>. So, we need to create a template of nginx configuration. This file will be called <code class="highlighter-rouge">default.ctmpl</code> and it looks like this.</p> <figure class="highlight"><pre><code class="language-conf" data-lang="conf">{{$<span class="n">blue</span>  := <span class="n">env</span> <span class="s2">"BLUE_NAME"</span>}}
{{$<span class="n">green</span> := <span class="n">env</span> <span class="s2">"GREEN_NAME"</span>}}
{{$<span class="n">live</span>  := <span class="n">file</span> <span class="s2">"/var/live"</span>}}
<span class="n">worker_processes</span>  <span class="m">1</span>;

<span class="n">events</span> {
    <span class="n">worker_connections</span>  <span class="m">1024</span>;
}

<span class="n">http</span> {
  <span class="n">upstream</span> <span class="n">blue</span> {
    <span class="n">least_conn</span>;
    {{<span class="n">range</span> <span class="n">service</span> $<span class="n">blue</span>}}
    <span class="n">server</span> {{.<span class="n">Address</span>}}:{{.<span class="n">Port</span>}} <span class="n">max_fails</span>=<span class="m">3</span> <span class="n">fail_timeout</span>=<span class="m">60</span> <span class="n">weight</span>=<span class="m">1</span>;{{<span class="n">else</span>}}
    <span class="n">server</span> <span class="m">127</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span>:<span class="m">55000</span>;{{<span class="n">end</span>}}
  }

  <span class="n">upstream</span> <span class="n">green</span> {
    <span class="n">least_conn</span>;
    {{<span class="n">range</span> <span class="n">service</span> $<span class="n">green</span>}}
    <span class="n">server</span> {{.<span class="n">Address</span>}}:{{.<span class="n">Port</span>}} <span class="n">max_fails</span>=<span class="m">3</span> <span class="n">fail_timeout</span>=<span class="m">60</span> <span class="n">weight</span>=<span class="m">1</span>;{{<span class="n">else</span>}}
    <span class="n">server</span> <span class="m">127</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">1</span>:<span class="m">55000</span>;{{<span class="n">end</span>}}
  }

  <span class="n">server</span> {
    <span class="n">listen</span> <span class="m">80</span> <span class="n">default</span>;

    <span class="n">location</span> / {
      {{<span class="n">if</span> <span class="n">eq</span> $<span class="n">live</span> <span class="s2">"blue"</span>}}
      <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">blue</span>;
      {{<span class="n">else</span>}}
      <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">green</span>;
      {{<span class="n">end</span>}}
    }
  }

  <span class="n">server</span> {
    <span class="n">listen</span> <span class="m">8080</span>;

    <span class="n">location</span> / {
      {{<span class="n">if</span> <span class="n">eq</span> $<span class="n">live</span> <span class="s2">"blue"</span>}}
      <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">green</span>;
      {{<span class="n">else</span>}}
      <span class="n">proxy_pass</span> <span class="n">http</span>://<span class="n">blue</span>;
      {{<span class="n">end</span>}}
    }
  }
}</code></pre></figure> <p>First of all, we set three variables:</p> <ul> <li><code class="highlighter-rouge">blue</code>: The docker service name of the blue environment, taken from environment variable <code class="highlighter-rouge">BLUE_NAME</code>.</li> <li><code class="highlighter-rouge">green</code>: The docker service name of the green environment, taken from environment variable <code class="highlighter-rouge">GREEN_NAME</code>.</li> <li><code class="highlighter-rouge">live</code>: Current live environment, <code class="highlighter-rouge">blue</code> or <code class="highlighter-rouge">green</code>, taken from the file <code class="highlighter-rouge">/var/live</code>.</li> </ul> <p>We will store the current live environment, <code class="highlighter-rouge">blue</code> or <code class="highlighter-rouge">green</code>, in the file <code class="highlighter-rouge">/var/live</code>. We cannot use environment variable for this because we cannot globally change the value of environment variable from inside a running docker image. So we write the current live environment, while switching, to the file and read its content from inside consul-template.</p> <p>Inside the http block, we create an upstream block for <code class="highlighter-rouge">blue</code> and <code class="highlighter-rouge">green</code>. Inside each of this upstream block, we specify the load balancing configuration for each service. The <code class="highlighter-rouge">least_conn</code> line causes nginx is to route traffic to the least connected instance. We need to generate <code class="highlighter-rouge">server</code> configuration lines for each instance of the service currently running. This is done by the code blocks, <code class="highlighter-rouge"><span class="p">{</span><span class="err">{range</span><span class="w"> </span><span class="err">service</span><span class="w"> </span><span class="err">$blue</span><span class="p">}</span><span class="err">}...</span><span class="p">{</span><span class="err">{end</span><span class="p">}</span><span class="err">}</span></code> and <code class="highlighter-rouge"><span class="p">{</span><span class="err">{range</span><span class="w"> </span><span class="err">service</span><span class="w"> </span><span class="err">$blue</span><span class="p">}</span><span class="err">}...</span><span class="p">{</span><span class="err">{end</span><span class="p">}</span><span class="err">}</span></code>. The code between these directives are repeated for each instance of the service running with <code class="highlighter-rouge"><span class="p">{</span><span class="err">{.Address</span><span class="p">}</span><span class="err">}</span></code> replaced by the address and <code class="highlighter-rouge"><span class="p">{</span><span class="err">{.Port</span><span class="p">}</span><span class="err">}</span></code> replaced by its port of that instance. If there is no instance of any service, we have the default <code class="highlighter-rouge">server 127.0.0.1:55000;</code> line that causes an error.</p> <p>Next we have the server block that is listening to the port 80. If the value of the <code class="highlighter-rouge">live</code> variable is <code class="highlighter-rouge">blue</code>, this is proxied to the <code class="highlighter-rouge">blue</code> app. If the value of <code class="highlighter-rouge">live</code> is <code class="highlighter-rouge">green</code>, this is proxied to <code class="highlighter-rouge">green</code> app. So, in essence, the port 80 will point to the live environment.</p> <p>Similarly, we have a server block that listens to port 8080. This is proxied to the staging environment. So, if the value of <code class="highlighter-rouge">live</code> is <code class="highlighter-rouge">blue</code>, this points to the <code class="highlighter-rouge">green</code> app and vice-versa. In any case, the port 80 will give the live environment and port 8080 will give the staging environment.</p> <h2 id="image-scripts">Image Scripts</h2> <p>We need a bash script, that acts as the entry point to this docker image. The file <code class="highlighter-rouge">start.sh</code> looks like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/sh</span>
nginx -g <span class="s1">'daemon off;'</span> &amp;
<span class="nb">echo</span> -n <span class="nv">$LIVE</span> &gt; /var/live
consul-template -consul<span class="o">=</span><span class="nv">$CONSUL_URL</span> -template<span class="o">=</span><span class="s2">"/templates/default.ctmpl:/etc/nginx/nginx.conf:nginx -s reload"</span>  </code></pre></figure> <p>The first line of the scipt starts up <code class="highlighter-rouge">nginx</code>. Now, we write the value of environment variable <code class="highlighter-rouge">LIVE</code> to the file <code class="highlighter-rouge">/var/live</code>. This environment variable contains the value <code class="highlighter-rouge">blue</code> or <code class="highlighter-rouge">green</code>, which is the initial live environment.</p> <p>We then start up <code class="highlighter-rouge">consul-template</code>. This command need two parameter. The first one is <code class="highlighter-rouge">-consul</code> and it requires the url for consul. We pass an environment variable for this. The next one is called <code class="highlighter-rouge">-template</code> and it consists of three parts seperated by a colon. The first one is the path of the template file. The second is the path where the generated configuration file must be placed. The third is the command that must by run when new configuration is generated. Here, we need to reload nginx.</p> <p>The consul-template listens for services and create new configuration file whenever a service starts or stops. The information about this is collected by the registrator services running in each node is our swarm and is stored in consul.</p> <p>Now, we need another script to switch the live environment. The script will accept a parameter, either <code class="highlighter-rouge">blue</code> of <code class="highlighter-rouge">green</code> and change the current live environment to that value. The file <code class="highlighter-rouge">switch</code> looks like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/sh</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$# </span>-eq 0 <span class="o">]</span>
  <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"No arguments supplied"</span>
    <span class="nb">exit </span>1
<span class="k">fi

if</span> <span class="o">[</span> <span class="nv">$1</span> <span class="o">=</span> <span class="s2">"blue"</span> <span class="o">]</span>
  <span class="k">then
    </span><span class="nb">echo</span> -n <span class="s2">"blue"</span> &gt; /var/live
  <span class="k">else
    </span><span class="nb">echo</span> -n <span class="s2">"green"</span> &gt; /var/live
<span class="k">fi

</span>consul-template -consul<span class="o">=</span><span class="nv">$CONSUL_URL</span> -template<span class="o">=</span><span class="s2">"/templates/default.ctmpl:/etc/nginx/nginx.conf:nginx -s reload"</span> -retry 30s -once </code></pre></figure> <p>If there is no arguments passed to this scripts, it exits showing the error message, <code class="highlighter-rouge">No arguments supplied</code>. If the parameter is <code class="highlighter-rouge">blue</code>, it is written to the file <code class="highlighter-rouge">/var/live</code>. Else, the value <code class="highlighter-rouge">green</code> is written to that file. This is now the current live environment.</p> <p>Finally, we run the <code class="highlighter-rouge">consul-template</code> command with the <code class="highlighter-rouge">once</code> parameter. This causes the consul-template to create new nginx configuration based on the new value in <code class="highlighter-rouge">/var/live</code> and reload nginx. This will switch the current live environment. As we have used the <code class="highlighter-rouge">once</code> parameter, the new configuration in made only once and consul-template will not listen for new services. For that, we have a consul-template running from our <code class="highlighter-rouge">start.sh</code> file.</p> <h2 id="blue-green-image">Blue-Green Image</h2> <p>Save these three files, <code class="highlighter-rouge">default.ctmpl</code>, <code class="highlighter-rouge">start.sh</code> and <code class="highlighter-rouge">switch</code>, in folder named <code class="highlighter-rouge">files</code>. In its parent, we can have the <code class="highlighter-rouge">Dockerfile</code> and <code class="highlighter-rouge">docker-compose.yml</code>. The <code class="highlighter-rouge">Dockerfile</code> contains information on how to build this docker image and will look like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">FROM nginx:alpine

RUN apk add --no-cache --virtual unzip
ADD https://releases.hashicorp.com/consul-template/0.14.0/consul-template_0.14.0_linux_amd64.zip /usr/bin/
RUN unzip /usr/bin/consul-template_0.14.0_linux_amd64.zip -d /usr/local/bin

COPY files/s<span class="k">*</span> /bin/
RUN chmod +x /bin/switch /bin/start.sh
COPY files/default.ctmpl /templates/

ENV LIVE blue
ENV BLUE_NAME blue
ENV GREEN_NAME green

EXPOSE 80 8080
ENTRYPOINT <span class="o">[</span><span class="s2">"/bin/start.sh"</span><span class="o">]</span></code></pre></figure> <p>This dockerfile uses <code class="highlighter-rouge">nginx:alpine</code> as the base and installs unzip and consul-template into it. It then copies the <code class="highlighter-rouge">start.sh</code>, <code class="highlighter-rouge">switch</code> and <code class="highlighter-rouge">default.ctmpl</code> to required locations and make the scripts executable.</p> <p>We also set the default values for following environment variables:</p> <ul> <li><code class="highlighter-rouge">LIVE</code>: The initial live environment. Set to <code class="highlighter-rouge">blue</code>.</li> <li><code class="highlighter-rouge">BLUE_NAME</code>: The docker service name of blue environment. Set to <code class="highlighter-rouge">blue</code>.</li> <li><code class="highlighter-rouge">GREEN_NAME</code>: The docker service name of green environment. Set to <code class="highlighter-rouge">green</code>.</li> </ul> <p>We expose the port 80 and 8080. The <code class="highlighter-rouge">start.sh</code> file will be the entry point to this image.</p> <h2 id="testing-blue-green-deployment">Testing Blue-Green deployment</h2> <p>To test blue-green deployment, we will use the following <code class="highlighter-rouge">docker-compose.yml</code> file.</p> <figure class="highlight"><pre><code class="language-conf" data-lang="conf"><span class="n">version</span>: <span class="s1">'2'</span>

<span class="n">services</span>:
  <span class="n">bg</span>:
    <span class="n">image</span>: <span class="n">hanzel</span>/<span class="n">blue</span>-<span class="n">green</span>
    <span class="n">container_name</span>: <span class="n">bg</span>
    <span class="n">ports</span>:
      - <span class="s2">"80:80"</span>
      - <span class="s2">"8080:8080"</span>
    <span class="n">environment</span>:
      - <span class="n">constraint</span>:<span class="n">node</span>==<span class="n">master</span>
      - <span class="n">CONSUL_URL</span>=${<span class="n">KV_IP</span>}:<span class="m">8500</span>
      - <span class="n">BLUE_NAME</span>=<span class="n">blue</span>
      - <span class="n">GREEN_NAME</span>=<span class="n">green</span>
      - <span class="n">LIVE</span>=<span class="n">blue</span>
    <span class="n">depends_on</span>:
      - <span class="n">green</span>
      - <span class="n">blue</span>
    <span class="n">networks</span>:
      - <span class="n">blue</span>-<span class="n">green</span>

  <span class="n">blue</span>:
    <span class="n">image</span>: <span class="n">hanzel</span>/<span class="n">nginx</span>-<span class="n">html</span>:<span class="m">1</span>
    <span class="n">ports</span>:
      - <span class="s2">"80"</span>
    <span class="n">environment</span>:
      - <span class="n">SERVICE_80_NAME</span>=<span class="n">blue</span>
    <span class="n">networks</span>:
      - <span class="n">blue</span>-<span class="n">green</span>

  <span class="n">green</span>:
    <span class="n">image</span>: <span class="n">hanzel</span>/<span class="n">nginx</span>-<span class="n">html</span>:<span class="m">2</span>
    <span class="n">ports</span>:
      - <span class="s2">"80"</span>
    <span class="n">environment</span>:
      - <span class="n">SERVICE_80_NAME</span>=<span class="n">green</span>
    <span class="n">networks</span>:
      - <span class="n">blue</span>-<span class="n">green</span>

<span class="n">networks</span>:
  <span class="n">blue</span>-<span class="n">green</span>:
    <span class="n">driver</span>: <span class="n">overlay</span></code></pre></figure> <p>We are using the version 2 of docker-compose file, with three services in an overlay network named <code class="highlighter-rouge">blue-green</code>. We have two versions of <code class="highlighter-rouge">hanzel/nginx-html</code> image running as blue and green services. We also have <code class="highlighter-rouge">hanzel/blue-green</code> image running for blue-green deployment.</p> <p>The first service is the blue service, named <code class="highlighter-rouge">blue</code>. The image used is version 1 of <code class="highlighter-rouge">hanzel/nginx-html</code>. We have mapped the port 80 of the container to some port in the host. We have set the environment variable <code class="highlighter-rouge">SERVICE_80_NAME</code> to <code class="highlighter-rouge">blue</code>. This causes the <code class="highlighter-rouge">registrator</code> to register this service into consul named as <code class="highlighter-rouge">blue</code>. This is the initial live environment.</p> <p>Similarly, we have the green service, named <code class="highlighter-rouge">green</code>. The image used here is version 2 of the <code class="highlighter-rouge">hanzel/nginx-html</code>. The environment variable <code class="highlighter-rouge">SERVICE_80_NAME</code> is set to <code class="highlighter-rouge">green</code> so that <code class="highlighter-rouge">registrator</code> will register it named as <code class="highlighter-rouge">green</code>. This is the initial statging environment.</p> <p>Finally, we have the <code class="highlighter-rouge">bg</code> service with <code class="highlighter-rouge">hanzel/blue-green</code> image. You can also build the image we just made in the previous section for this service by replacing the line <code class="highlighter-rouge">image: hanzel/blue-green</code> with <code class="highlighter-rouge">build: .</code> and placing this file along with the <code class="highlighter-rouge">Dockerfile</code> we made in the previous section.</p> <p>We map the ports <code class="highlighter-rouge">80</code> and <code class="highlighter-rouge">8080</code> of the container to that of the host. We also need to set the following environment variables.</p> <ul> <li><code class="highlighter-rouge">constraint:node</code>: The name of the node where this service should run. We want this service to always run on the <code class="highlighter-rouge">master</code> node.</li> <li><code class="highlighter-rouge">CONSUL_URL</code>: The url endpoint of consul. We have set it to <code class="highlighter-rouge">${KV_IP}:8500</code>, where <code class="highlighter-rouge">KV_IP</code> is the environment variable we have set while making the swarm.</li> <li><code class="highlighter-rouge">BLUE_NAME</code>: The docker service name of the blue image. Set to <code class="highlighter-rouge">blue</code>.</li> <li><code class="highlighter-rouge">GREEN_NAME</code>: The docker service name of the green image. Set to <code class="highlighter-rouge">green</code>.</li> <li><code class="highlighter-rouge">LIVE</code>: The initial live environment, blue or green. Set to <code class="highlighter-rouge">blue</code>.</li> </ul> <p>We can start the services with the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-compose up -d</code></pre></figure> <p>This will start up a single instance of each of these three services. We can scale the blue and green services to 3 instances each with the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-compose scale <span class="nv">blue</span><span class="o">=</span>3 <span class="nv">green</span><span class="o">=</span>3</code></pre></figure> <p>These will create two new instances for blue and green service. You can see the running services of docker-compose with the <code class="highlighter-rouge">docker-compose ps</code> command. The output of the command will look something like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">Name          Command                State                               Ports
----------------------------------------------------------------------------------------------------------
<span class="nb">bg</span>            /bin/start.sh          Up      443/tcp, 45.55.185.18:80-&gt;80/tcp, 45.55.185.18:8080-&gt;8080/tcp
tmp_blue_1    nginx -g daemon off;   Up      443/tcp, 45.55.185.18:32777-&gt;80/tcp
tmp_blue_2    nginx -g daemon off;   Up      443/tcp, 159.203.119.37:32769-&gt;80/tcp
tmp_blue_3    nginx -g daemon off;   Up      443/tcp, 45.55.185.18:32778-&gt;80/tcp
tmp_green_1   nginx -g daemon off;   Up      443/tcp, 159.203.119.37:32768-&gt;80/tcp
tmp_green_2   nginx -g daemon off;   Up      443/tcp, 45.55.185.18:32779-&gt;80/tcp
tmp_green_3   nginx -g daemon off;   Up      443/tcp, 159.203.119.37:32770-&gt;80/tcp</code></pre></figure> <p>We can see the live production environment from the url given by the command, <code class="highlighter-rouge">docker-compose port bg 80</code>. You will get some IP address like <code class="highlighter-rouge">45.55.185.18:80</code>, which is the IP for the <code class="highlighter-rouge">master</code> node. Go to this url and we can see the live environment, currently <code class="highlighter-rouge">blue</code>, showing <code class="highlighter-rouge">Version 1</code>. You can see the staging environment, currently <code class="highlighter-rouge">green</code>, by going to port <code class="highlighter-rouge">8080</code> of the same IP. That will be <code class="highlighter-rouge">45.55.185.18:8080</code> in this case. This will show you <code class="highlighter-rouge">Version 2</code>.</p> <p>Now, the users can see the version 1 of your app and only you can see version 2. You can test the new version and if you are satisfied, you can switch the live environment to <code class="highlighter-rouge">green</code>. To do this, use the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker <span class="nb">exec bg </span>switch green</code></pre></figure> <p>Now, the live version is <code class="highlighter-rouge">green</code> and at port 80, you can see version 2 and at port 8080, you can see version 1. You can see the new nginx configuration with the command, <code class="highlighter-rouge">docker exec bg cat /etc/nginx/nginx.conf</code>. The output of this command will look like this.</p> <figure class="highlight"><pre><code class="language-nginx" data-lang="nginx"><span class="k">worker_processes</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">events</span> <span class="p">{</span>
  <span class="kn">worker_connections</span>  <span class="mi">1024</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">http</span> <span class="p">{</span>
  <span class="kn">upstream</span> <span class="s">blue</span> <span class="p">{</span>
    <span class="kn">least_conn</span><span class="p">;</span>

    <span class="kn">server</span> <span class="nf">10.132.12.95</span><span class="p">:</span><span class="mi">32769</span> <span class="s">max_fails=3</span> <span class="s">fail_timeout=60</span> <span class="s">weight=1</span><span class="p">;</span>
    <span class="kn">server</span> <span class="nf">10.132.35.39</span><span class="p">:</span><span class="mi">32777</span> <span class="s">max_fails=3</span> <span class="s">fail_timeout=60</span> <span class="s">weight=1</span><span class="p">;</span>
    <span class="kn">server</span> <span class="nf">10.132.35.39</span><span class="p">:</span><span class="mi">32778</span> <span class="s">max_fails=3</span> <span class="s">fail_timeout=60</span> <span class="s">weight=1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kn">upstream</span> <span class="s">green</span> <span class="p">{</span>
    <span class="kn">least_conn</span><span class="p">;</span>

    <span class="kn">server</span> <span class="nf">10.132.12.95</span><span class="p">:</span><span class="mi">32768</span> <span class="s">max_fails=3</span> <span class="s">fail_timeout=60</span> <span class="s">weight=1</span><span class="p">;</span>
    <span class="kn">server</span> <span class="nf">10.132.12.95</span><span class="p">:</span><span class="mi">32770</span> <span class="s">max_fails=3</span> <span class="s">fail_timeout=60</span> <span class="s">weight=1</span><span class="p">;</span>
    <span class="kn">server</span> <span class="nf">10.132.35.39</span><span class="p">:</span><span class="mi">32779</span> <span class="s">max_fails=3</span> <span class="s">fail_timeout=60</span> <span class="s">weight=1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kn">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">80</span> <span class="s">default</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
      <span class="kn">proxy_pass</span> <span class="s">http://green</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kn">server</span> <span class="p">{</span>
    <span class="kn">listen</span> <span class="mi">8080</span><span class="p">;</span>

    <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
      <span class="kn">proxy_pass</span> <span class="s">http://blue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>You can always check the current live environment using the command, <code class="highlighter-rouge">docker exec bg cat /var/live</code>. Now, <code class="highlighter-rouge">blue</code> is the staging environment and we can check version 3 there. So in the blue service of the <code class="highlighter-rouge">docker-compose.yml</code> file, change the line <code class="highlighter-rouge">image: hanzel/nginx-html:1</code> to <code class="highlighter-rouge">image: hanzel/nginx-html:3</code>. To update the blue service, run the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-compose up -d blue</code></pre></figure> <p>All three instances for <code class="highlighter-rouge">blue</code> services will be upgraded from version 1 to version 3 now. The staging environment at port <code class="highlighter-rouge">8080</code> of the <code class="highlighter-rouge">bg</code> service will now show <code class="highlighter-rouge">Version 3</code>. You can check this version and if it is okay for production, switch the live environment to <code class="highlighter-rouge">blue</code> with the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker <span class="nb">exec bg </span>switch blue</code></pre></figure> <p>Now, live environment at port <code class="highlighter-rouge">80</code> will show <code class="highlighter-rouge">Version 3</code> and the staging environment at port <code class="highlighter-rouge">8080</code> will show <code class="highlighter-rouge">Version 2</code>. You can repeat this process for newer versions.</p> <h2 id="conclusion">Conclusion</h2> <p>In this article, we have seen how to build a blue-green deployment system with Dockers to release new version of the app without downtime. We have made a docker image to implement this blue-green deployment and tested it on an app deployed with Docker Swarm.</p> <p>Once you are done, the services can be stopped and the hosts removed with the following commands.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-compose down
docker-machine stop consul master slave
docker-machine rm consul master slave</code></pre></figure> <p class="post-meta">Tags: blue-green, live, staging, docker, swarm, registrator, nginx, consul, consul-template, overlay, digitalocean, compose, machine, bash, Dockerfile, and devops </p> </article> <article class="post-comments" id="comments-box"> <h1 class="page-title">Comments</h1> <form id="new-comment"> <input type="text" id="nameField" placeholder="Enter your name" required><br/> <textarea id="textField" placeholder="Your comments please." required></textarea><br/> <button type="submit" id="commentBtn">Post Comment</button> </form> <div id="comments"></div> </article> </section> <aside class="post-aside"> <div class ="aside" id="cat-list"> <h1 class="page-heading">Categories</h1> <a href="/categories/misc">Misc</a><br/> <a href="/categories/jekyll">Jekyll</a><br/> <a href="/categories/cloud">Cloud</a><br/> <a href="/categories/Node.js">Node.js</a><br/> <a href="/categories/javascript">Javascript</a><br/> <a href="/categories/devops">Devops</a><br/> </div> <div class ="aside"> <h1 class="page-heading">Related Stories</h1> <a href=/stories/hello-world/>hello world :)</a><br/><a href=/stories/tricks-with-ssh/>Tricks with SSH</a><br/><a href=/stories/auto-scaling-with-docker/>Auto Scaling with Docker</a><br/><a href=/stories/generators-in-javascript-and-python/>Generators in JavaScript and Python</a><br/><a href=/stories/orchestrate-docker-containers-with-tutum/>Orchestrate Docker containers with Tutum</a><br/> </div> <p class="rss-subscribe">subscribe <a href="/feed">via RSS</a></p> <a href="#">Scroll to Top</a> </aside> </div> </div> </div> <footer class="site-footer"> <div class="footer-wrap"> <h2 class="footer-heading"><a href="/">botleg</a></h2> <div class="footer-col-wrapper"> <div class="footer-col footer-col-1"> <ul class="contact-list"> <li>By Hanzel Jesheen</li> <li><a href="mailto:blog@botleg.com">blog@botleg.com</a></li> </ul> </div> <div class="footer-col footer-col-2"> <ul class="social-media-list"> <li> <a href="https://github.com/botleg"> <span class="footer-icon"> <svg viewBox="0 0 16 16" width="16px" height="16px"> <use xlink:href="/assets/images/sprites.svg#gh"></use> </svg> </span> <span class="username">github</span> </a> </li> <li class="username"> <span class="footer-icon"> <svg viewBox="0 0 24 24" width="16px" height="16px"> <use xlink:href="/assets/images/sprites.svg#rss"></use> </svg> </span> subscribe <a href="/feed">via RSS</a> </li> </ul> </div> <div class="footer-col footer-col-3"> <p>Hi, botleg is a blog where you can find tutorials and techniques in web development, devops, databases, cloud computing and anything related to technology.</p> </div> </div> </div> </footer> <style type="text/css">body,h1,h2{font-weight:300}.wrapper:after{clear:both}html{box-sizing:border-box}body{background-color:#fdfdfd;color:#111;font-family:Helvetica,Arial,sans-serif;font-size:18px;line-height:1.6;}.wrapper section{margin-top:30px}a{color:#2a7ae2;text-decoration:none}.site-header{min-height:60px;position:relative}.site-title{margin-bottom:0;float:left;font-size:28px;line-height:60px;text-transform:lowercase;color:#e8e8e8}.post-header{box-align:center;justify-content:center;color:#fdfdfd;display:flex;height:300px;margin-bottom:10px}.rss-icon,#searchbox{display:none;}.post-header .header-content{text-align:center;max-width:600px}.icon{background-position:10px center;background-repeat:no-repeat;background-size:30px;padding:0 30px 0 45px}.icon span{color:#fdfdfd;display:none}@media screen and (min-width:400px){.icon span{display:inline}}.post-title{color:#e8e8e8;font-size:36px}.page-content,.post-content{margin-bottom:20px}.page-content h2,.post-content h2{font-size:32px}</style> <script> var cb = function() { var l = document.createElement('link'); l.rel = 'stylesheet'; l.href = '/assets/main.css?v310'; var h = document.getElementsByTagName('head')[0]; h.parentNode.insertBefore(l, h); }; var raf = requestAnimationFrame || mozRequestAnimationFrame || webkitRequestAnimationFrame || msRequestAnimationFrame; if (raf) raf(cb); else window.addEventListener('load', cb); </script> <script async type="text/javascript" src="/assets/js/post.js"></script> </body> </html>
