<!DOCTYPE html> <html> <head> <title>Monitoring Docker Swarm with cAdvisor, InfluxDB and Grafana - botleg</title> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="description" content="Monitoring is essential to know the state of our running applications. When you are running your applications in a scalable environment like Docker Swarm, yo..."> <meta name="author" content="Hanzel Jesheen"> <meta name="twitter:card" content="Monitoring is essential to know the state of our running applications. Using InfluxDB, Grafana and cAdvisor, we will setup a scalable monitoring solution for Docker Swarm." /> <meta name="twitter:site" content="@HanzelJesheen" /> <meta name="twitter:creator" content="@HanzelJesheen" /> <meta property="og:url" content="https://botleg.com/stories/monitoring-docker-swarm-with-cadvisor-influxdb-and-grafana/" /> <meta property="og:type" content="article" /> <meta property="og:title" content="Monitoring Docker Swarm with cAdvisor, InfluxDB and Grafana" /> <meta property="og:description" content="Monitoring is essential to know the state of our running applications. Using InfluxDB, Grafana and cAdvisor, we will setup a scalable monitoring solution for Docker Swarm." /> <meta property="og:image" content="" /> <meta property="og:site_name" content="botleg" /> <meta property="article:author" content="Hanzel Jesheen" /> <meta itemprop="name" content="Monitoring Docker Swarm with cAdvisor, InfluxDB and Grafana"> <meta itemprop="description" content="Monitoring is essential to know the state of our running applications. When you are running your applications in a scalable environment like Docker Swarm, yo..."> <link rel="canonical" href="https://botleg.com/stories/monitoring-docker-swarm-with-cadvisor-influxdb-and-grafana/"> <link rel="alternate" type="application/rss+xml" title="botleg" href="https://botleg.com/feed" /> </head> <body> <div class="page-content"> <div class="post"> <header style="background:#D31027;background-image:linear-gradient(160deg, #EA384D, #D31027);background-image:-moz-linear-gradient(160deg, #EA384D, #D31027);background-image:-webkit-linear-gradient(160deg, #EA384D, #D31027);background-image:-o-linear-gradient(160deg, #EA384D, #D31027);background-image:-ms-linear-gradient(160deg, #EA384D, #D31027); "> <section class="site-header"> <div class="wrapper"> <a class="site-title" href="/">Botleg</a> <div id="search"> <a href="/feed/index.xml"><span class="rss-icon"> <svg viewBox="0 0 24 24" width="30px" height="30px"> <use xlink:href="/assets/images/sprites.svg#rss"></use> </svg></span> </a> <form id="searchform"> <input type="text" placeholder="search" id="searchbox"> </form> </div> </div> </section> <section class="post-header"> <div class="header-content"> <h1 class="post-title">Monitoring Docker Swarm with cAdvisor, InfluxDB and Grafana</h1> <a class="icon gh" href="https://github.com/botleg/swarm-monitoring" target="blank"><span>View Code</span></a> </div> </section> </header> <div class="wrapper"> <section> <article class="post-content"> <p class="post-meta">Written by Hanzel Jesheen on Mar 30, 2017 | <a href="/categories/devops">devops</a> </p> <p>Monitoring is essential to know the state of our running applications. When you are running your applications in a scalable environment like Docker Swarm, you need a scalable monitoring solution as well. In this article, we will setup just that.</p> <p>We will install <a href="https://github.com/google/cadvisor">cAdvisor</a> agents in each nodes to collect host and container metrics. We will save these time-series metrics in <a href="https://github.com/influxdata/influxdb">InfluxDB</a>. We will use <a href="https://github.com/grafana/grafana">Grafana</a> to setup dashboards for this metrics. All these tools are open-source and can be deployed as a container.</p> <p>We will use the Docker Swarm Mode to build the cluster and deploy these services as a stack. This allows for a dynamic setup for monitoring. Once we deploy this stack in a swarm, any new nodes joining the swarm will be automatically monitored. All the files used for this project can be found <a href="https://github.com/botleg/swarm-monitoring">here</a>.</p> <h2 id="tools-overview">Tools Overview</h2> <p>There are plenty of options for monitoring solutions. We are using open-source and container friendly services to build our stack. Our stack comprises of the following services.</p> <h1 id="cadvisor">cAdvisor</h1> <p><a href="https://github.com/google/cadvisor">cAdvisor</a> collects the metric from the host and docker containers. It is deployed as a docker image with shared volumes to docker socket and root file system of the host. cAdvisor pushed these metrics to a bunch of time-series database including InfluxDB, Prometheus, etc. It even has a web UI that shows graphs of the metrics collected.</p> <h1 id="influxdb">InfluxDB</h1> <blockquote> <p>Scalable datastore for metrics, events, and real-time analytics</p> </blockquote> <p><a href="https://github.com/influxdata/influxdb">InfluxDB</a> is open source time series database. You can save numeric value metrics with tags. It supports a SQL like query language to query for data. The tags let us filter data for a specific host and even a spefic container.</p> <h1 id="grafana">Grafana</h1> <blockquote> <p>Grafana is an open source, feature rich metrics dashboard and graph editor for Graphite, Elasticsearch, OpenTSDB, Prometheus and InfluxDB.</p> </blockquote> <p><a href="https://github.com/grafana/grafana">Grafana</a> is a popular graphing tool that lets you build dashboards with data from Graphite, Elasticsearch, OpenTSDB, Prometheus and, of course, InfluxDB. From version 4 of grafana, you can also setup alerts based on query conditions. We will setup dashboard that can be drilled down to specific host and service.</p> <h2 id="docker-swarm-mode">Docker Swarm Mode</h2> <p>Docker introduced <code class="highlighter-rouge">Swarm Mode</code> from version 1.12.0. This allows us to easily create and manage swarm of multiple hosts. The swarm mode has the key-value store for service discovery and orchestration capability in-built. You can join hosts into a swarm as a manager or a worker. Generally, manager handles the orchestration part and workers are used to run the containers. Since this is for demostration, we will run InfluxDB and Grafana in the manager itself.</p> <p>Swarm Mode has an interesting feature called <code class="highlighter-rouge">router mesh</code>. This acts as virtual load balancer. Let’s say that we have 10 containers running across 5 nodes and they listen to the port 80. Now, if you access the port 80 of any of the hosts. You will directed to any one of the 10 running instance, even the instances that are not even in that particular host. So you can publish the IP of any of the nodes and the requests will be automatically load balanced between all the 10 containers.</p> <p>To follow along with the demonstration, you need to have the following prerequisites:</p> <ul> <li><code class="highlighter-rouge">Docker</code>: version &gt;= 17.10 CE, to support Docker Compose File version 3 and Swarm Mode.</li> <li><code class="highlighter-rouge">Docker Machine</code>: version &gt;= 0.12</li> <li><code class="highlighter-rouge">Docker Compose</code>: version &gt;= 1.16, to support Docker Compose file version 3</li> </ul> <p>We will be creating 3 local VMs to form the swarm using the <code class="highlighter-rouge">Virtualbox</code> plugin of <code class="highlighter-rouge">docker-machine</code>. For this, you need to have <a href="https://www.virtualbox.org/">Virtualbox</a> installed in the system. You may also deploy the nodes in cloud services using different plugins. The steps after creating in the VMs are same for all the plugins. You can read more about docker-machine <a href="https://docs.docker.com/machine/get-started/">here</a>.</p> <p>We will using the default options to create the VMs. To know more about the options available, check <a href="https://docs.docker.com/machine/drivers/virtualbox/">here</a>. We will create a host named <code class="highlighter-rouge">manager</code> that acts as the manager for the swarm and two hosts <code class="highlighter-rouge">agent1</code> and <code class="highlighter-rouge">agent2</code> to act as the workers. You may create as many nodes as you want. Just repeat the commands with the host names changed. To create the VMs, execute the follwing commands.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-machine create manager
docker-machine create agent1
docker-machine create agent2</code></pre></figure> <p>These commands may take some time. After creating the VMS, the output for the command <code class="highlighter-rouge">docker-machine ls</code> should look something like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER        ERRORS
agent1    -        virtualbox   Running   tcp://192.168.99.101:2376           v17.03.1-ce
agent2    -        virtualbox   Running   tcp://192.168.99.102:2376           v17.03.1-ce
manager   -        virtualbox   Running   tcp://192.168.99.100:2376           v17.03.1-ce          </code></pre></figure> <p>Now you have to switch context to use the docker engine in the <code class="highlighter-rouge">manager</code>. We will be doing the rest of the demostration in the docker engine of the <code class="highlighter-rouge">manager</code> and NOT in our local system. To do this, run the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">eval</span> <span class="sb">`</span>docker-machine env manager<span class="sb">`</span></code></pre></figure> <p>We have now switched over to the docker engine in <code class="highlighter-rouge">manager</code>. We will initialize the swarm with <code class="highlighter-rouge">manager</code> acting as its manager. We have to mention the IP which will be published for other nodes to join the swarm. We will use the IP of <code class="highlighter-rouge">manager</code> for this. The command, <code class="highlighter-rouge">docker-machine ip manager</code> will get you this. So, to create the swarm, run the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker swarm init --advertise-addr <span class="sb">`</span>docker-machine ip manager<span class="sb">`</span></code></pre></figure> <p>Now, we need to add the two workers to this swarm. To do this, we need to pass a <code class="highlighter-rouge">Join Token</code> and the IP published when the swarm was created. To get the token for joining the swarm as a worker, you can run the command <code class="highlighter-rouge">docker swarm join-token -q worker</code>. As before, <code class="highlighter-rouge">docker-machine ip manager</code> will get the IP for joining and the default port for this is <code class="highlighter-rouge">2377</code>. We could join the swarm by changing the context to each of the workers, but it is easier to run the commands as via SSH. To join workers to the swarm, run the following commands.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-machine ssh agent1 docker swarm join --token <span class="sb">`</span>docker swarm join-token -q worker<span class="sb">`</span> <span class="sb">`</span>docker-machine ip manager<span class="sb">`</span>:2377
docker-machine ssh agent2 docker swarm join --token <span class="sb">`</span>docker swarm join-token -q worker<span class="sb">`</span> <span class="sb">`</span>docker-machine ip manager<span class="sb">`</span>:2377</code></pre></figure> <p>You can see the nodes in the swarm with the command <code class="highlighter-rouge">docker node ls</code>. Once the workers are added the output of the command must look something like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">ID                           HOSTNAME  STATUS  AVAILABILITY  MANAGER STATUS
3j231njh03spl0j8h67z069cy <span class="k">*</span>  manager   Ready   Active        Leader
muxpteij6aldkixnl31f0asar    agent1    Ready   Active
y2gstaqpqix1exz09nyjn8z41    agent2    Ready   Active</code></pre></figure> <h2 id="docker-stack">Docker Stack</h2> <p>With the version 3 of <code class="highlighter-rouge">docker-compose</code> file, we can define the entire stack with the deployment strategy with one file and deploy it with one command. The main difference between version 2 and 3 of docker-compose file is the introduction of the <code class="highlighter-rouge">deploy</code> parameter for each service. This parameter will define where and how you want the containers to be deployed. The <code class="highlighter-rouge">docker-compose</code> file for the monitoring file is given below.</p> <figure class="highlight"><pre><code class="language-conf" data-lang="conf"><span class="n">version</span>: <span class="s1">'3'</span>

<span class="n">services</span>:
  <span class="n">influx</span>:
    <span class="n">image</span>: <span class="n">influxdb</span>
    <span class="n">volumes</span>:
      - <span class="n">influx</span>:/<span class="n">var</span>/<span class="n">lib</span>/<span class="n">influxdb</span>
    <span class="n">deploy</span>:
      <span class="n">replicas</span>: <span class="m">1</span>
      <span class="n">placement</span>:
        <span class="n">constraints</span>:
          - <span class="n">node</span>.<span class="n">role</span> == <span class="n">manager</span>

  <span class="n">grafana</span>:
    <span class="n">image</span>: <span class="n">grafana</span>/<span class="n">grafana</span>
    <span class="n">ports</span>:
      - <span class="m">0</span>.<span class="m">0</span>.<span class="m">0</span>.<span class="m">0</span>:<span class="m">80</span>:<span class="m">3000</span>
    <span class="n">volumes</span>:
      - <span class="n">grafana</span>:/<span class="n">var</span>/<span class="n">lib</span>/<span class="n">grafana</span>
    <span class="n">depends_on</span>:
      - <span class="n">influx</span>
    <span class="n">deploy</span>:
      <span class="n">replicas</span>: <span class="m">1</span>
      <span class="n">placement</span>:
        <span class="n">constraints</span>:
          - <span class="n">node</span>.<span class="n">role</span> == <span class="n">manager</span>

  <span class="n">cadvisor</span>:
    <span class="n">image</span>: <span class="n">google</span>/<span class="n">cadvisor</span>
    <span class="n">hostname</span>: <span class="s1">'{{.Node.Hostname}}'</span>
    <span class="n">command</span>: -<span class="n">logtostderr</span> -<span class="n">docker_only</span> -<span class="n">storage_driver</span>=<span class="n">influxdb</span> -<span class="n">storage_driver_db</span>=<span class="n">cadvisor</span> -<span class="n">storage_driver_host</span>=<span class="n">influx</span>:<span class="m">8086</span>
    <span class="n">volumes</span>:
      - /:/<span class="n">rootfs</span>:<span class="n">ro</span>
      - /<span class="n">var</span>/<span class="n">run</span>:/<span class="n">var</span>/<span class="n">run</span>:<span class="n">rw</span>
      - /<span class="n">sys</span>:/<span class="n">sys</span>:<span class="n">ro</span>
      - /<span class="n">var</span>/<span class="n">lib</span>/<span class="n">docker</span>/:/<span class="n">var</span>/<span class="n">lib</span>/<span class="n">docker</span>:<span class="n">ro</span>
    <span class="n">depends_on</span>:
      - <span class="n">influx</span>
    <span class="n">deploy</span>:
      <span class="n">mode</span>: <span class="n">global</span>

<span class="n">volumes</span>:
  <span class="n">influx</span>:
    <span class="n">driver</span>: <span class="n">local</span>
  <span class="n">grafana</span>:
    <span class="n">driver</span>: <span class="n">local</span></code></pre></figure> <p>We will start by saying that we are using the version 3 of <code class="highlighter-rouge">docker-compose</code> file. We have following 3 services in the stack.</p> <h1 id="influx">influx</h1> <p>This uses the <code class="highlighter-rouge">influxdb</code> image and for persistent storage, we are creating a volume named <code class="highlighter-rouge">influx</code> that is mounted to the <code class="highlighter-rouge">/var/lib/influxdb</code> folder in the container. In the deploy key, we are saying that we need one copy of InfluxDB which we will place in the <code class="highlighter-rouge">manager</code>. Since we are using docker engine in the <code class="highlighter-rouge">manager</code>, we can execute commands to this container from here itself. As both the other services needs influxDB to run, we will add a <code class="highlighter-rouge">depends_on</code> key to other services with <code class="highlighter-rouge">influx</code> in it.</p> <h1 id="grafana-1">grafana</h1> <p>We will use the image <code class="highlighter-rouge">grafana/grafana</code> and expose the port <code class="highlighter-rouge">3000</code> of the container to port <code class="highlighter-rouge">80</code> of the host. The <code class="highlighter-rouge">router mesh</code> feature will then let us access grafana from port 80 of any host in the swarm. We have another volume named <code class="highlighter-rouge">grafana</code> mounted to <code class="highlighter-rouge">/var/lib/grafana</code> in the container for persistent data. As before, we also deploy one copy of grafana in the <code class="highlighter-rouge">manager</code>.</p> <h1 id="cadvisor-1">cadvisor</h1> <p>cAdvisor service has much more configuration required than the other services. To know more, check <a href="https://github.com/google/cadvisor">this</a> out. The hostname key is a tricky one. We intend to put one agent in each node of the swarm and this container will collect all metrics from the node and the containers running in it. When cAdvisor send metrics to InfluxDB, it send it with a tag <code class="highlighter-rouge">machine</code> that contains the hostname of cAdvisor container. We need to match it with the hostname of the node running it. Docker stacks allows templating in naming. We have named the containers with the ID of the node running it so that we know where the metric is coming from. The is done by the value <code class="highlighter-rouge">'{{.Node.Hostname}}'</code>.</p> <p>We also add some command line parameters to cadvisor. The <code class="highlighter-rouge">logtostderr</code> redirects the logs generated by cadvsior to <code class="highlighter-rouge">stderr</code>, which makes it easy to debug. The <code class="highlighter-rouge">docker_only</code> flag says that we are only interested in docker based containers. The next three parameters defines where you want metrics to be pushed for storage. We are asking cAdvisor to push the metrics to <code class="highlighter-rouge">cadvisor</code> database in InfluxDB server listening at <code class="highlighter-rouge">influx:8086</code>. This will send the metrics to the influx service in the stack. In a stack, all ports are exposed and you don’t have to specifically mention them.</p> <p>cAdvisor need the volumes mentioned in the file to collect the metrics from the host and docker system. We use the mode <code class="highlighter-rouge">global</code> for deploy in cadvisor service. This will ensure that exactly one instance of cadvisor service will be run in each node of the swarm.</p> <p>Finally, at the end of the file, we have the <code class="highlighter-rouge">volumes</code> key with the <code class="highlighter-rouge">influx</code> and <code class="highlighter-rouge">grafana</code> volumes. As we are using the <code class="highlighter-rouge">local</code> driver for both the volumes, the volumes will be stored in the <code class="highlighter-rouge">manager</code>.</p> <p>To deploy this stack, save the above file as <code class="highlighter-rouge">docker-stack.yml</code> and run the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker stack deploy -c docker-stack.yml monitor</code></pre></figure> <p>This will start the services in the stack which is named <code class="highlighter-rouge">monitor</code>. This might take some time the first time as the nodes have to download the images. Also, you need to create the database named <code class="highlighter-rouge">cadvisor</code> in InfluxDB to store the metrics.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker <span class="nb">exec</span> <span class="sb">`</span>docker ps | grep -i influx | awk <span class="s1">'{print $1}'</span><span class="sb">`</span> influx -execute <span class="s1">'CREATE DATABASE cadvisor'</span></code></pre></figure> <p>This command might fail saying that the <code class="highlighter-rouge">influx</code> container doesn’t exist. This is beacuse the container is not yet ready. Wait for some time and run it again. We are able to run the commands in the <code class="highlighter-rouge">influx</code> service beacuse it is running in <code class="highlighter-rouge">manager</code> and we are using its docker engine. To find the ID of InfluxDB container, you can use the command <code class="highlighter-rouge">docker ps | grep -i influx | awk '{print $1}'</code> and we are executing the command <code class="highlighter-rouge">influx -execute 'CREATE DATABASE cadvisor'</code> to create the new database names <code class="highlighter-rouge">cadvisor</code>.</p> <p>To see the services in the stack, you can use the command <code class="highlighter-rouge">docker stack services monitor</code>, the output of the command will look like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">ID            NAME              MODE        REPLICAS  IMAGE
0fru8w12pqdx  monitor_influx    replicated  1/1       influxdb:latest
m4r34h5ho984  monitor_grafana   replicated  1/1       grafana/grafana:latest
s1yeap330m7e  monitor_cadvisor  global      3/3       google/cadvisor:latest</code></pre></figure> <p>You can see the running containers in the stack with the command <code class="highlighter-rouge">docker stack ps monitor</code>. Its output will look like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">ID            NAME                                        IMAGE                   NODE     DESIRED STATE  CURRENT STATE               ERROR  PORTS
n7kobaozqzj6  monitor_cadvisor.y78ac29r904m8uy6hxffb7uvn  google/cadvisor:latest  agent2   Running        Running about a minute ago
1nsispop3hsu  monitor_cadvisor.z52c9vloiutl5dbuj5lnykzvl  google/cadvisor:latest  agent1   Running        Running about a minute ago
9n6djc80mamd  monitor_cadvisor.qn82bfj5cpin2cpmx9qv1j56s  google/cadvisor:latest  manager  Running        Running about a minute ago
hyr8piriwa0x  monitor_grafana.1                           grafana/grafana:latest  manager  Running        Running about a minute ago
zk7u8g73ko5w  monitor_influx.1                            influxdb:latest         manager  Running        Running about a minute ago</code></pre></figure> <h2 id="setting-up-grafana">Setting Up Grafana</h2> <p>Once the services are deployed, you can open up grafana with the IP of any node in the swarm. We will open the IP of manager with the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">open http://<span class="sb">`</span>docker-machine ip manager<span class="sb">`</span></code></pre></figure> <p>By default, use the username <code class="highlighter-rouge">admin</code> and password <code class="highlighter-rouge">admin</code> to login to grafana. The first thing to do in grafana is to add InfluxDB as the datasource. In the home page, there must be a <code class="highlighter-rouge">Create your first data source</code> link, click that. If the link is not visible, you can select <code class="highlighter-rouge">Data Sources</code> from menu and choosing <code class="highlighter-rouge">Add data source</code> from there. This will give you the form to add a new Data Source.</p> <p><img src="/assets/images/grafana-datasource@2x.jpg" srcset="/assets/images/grafana-datasource@1x.jpg 300w, /assets/images/grafana-datasource@2x.jpg 600w, /assets/images/grafana-datasource@3x.jpg 900w" sizes="(min-width: 960px) 900px, 100vw" alt="Add Data Source in Grafana" class="center-image" /> <em class="image-caption">Add Data Source in Grafana</em></p> <p>You can give any name for the source. Check the default box, so that you won’t have to mention the data source everywhere. Choose the type as <code class="highlighter-rouge">InfluxDB</code>. Now, the URL is <code class="highlighter-rouge">http://influx:8086</code> and Access is <code class="highlighter-rouge">proxy</code>. This will point to the port listened by the InfluxDb container. Finally give the Database as <code class="highlighter-rouge">cadvisor</code> and click the <code class="highlighter-rouge">Save and Test</code> button. This should give the message <code class="highlighter-rouge">Data source is working</code>.</p> <p>In the <a href="https://github.com/botleg/swarm-monitoring">github repository</a>, I have added the file <code class="highlighter-rouge">dashboard.json</code>, that can be imported to Grafana. This will provide a dashboard that monitors the systems and the containers running in the swarm. We will import the dashboard now and talk about it in the next section. From the menu, hover over <code class="highlighter-rouge">Dashboards</code> and select <code class="highlighter-rouge">Import Option</code>. Click the <code class="highlighter-rouge">Upload .json file</code> button and choose the <code class="highlighter-rouge">dashboard.json</code> file. Select the data source and click the <code class="highlighter-rouge">Import</code> button to import this dashboard.</p> <h2 id="grafana-dashboard">Grafana Dashboard</h2> <p><img src="/assets/images/grafana-dashboard@2x.jpg" srcset="/assets/images/grafana-dashboard@1x.jpg 300w, /assets/images/grafana-dashboard@2x.jpg 600w, /assets/images/grafana-dashboard@3x.jpg 900w" sizes="(min-width: 960px) 900px, 100vw" alt="Grafana Dashboard" class="center-image" /> <em class="image-caption">Grafana Dashboard</em></p> <p>The dashboard imported to Grafana will monitor the host and containers in the swarm. You can drill down to host level and even to the container level in each host. To be able to do this, we are using two variables. To add variables to Grafana dashboard, we use the templating feature. To know more about templating with InfluxDB, check <a href="http://docs.grafana.org/features/datasources/influxdb/#templating">here</a>. There are two varibles, <code class="highlighter-rouge">host</code> to select the node and <code class="highlighter-rouge">container</code> to select the container. To see the variables, select Settings from dashboard page and choose <code class="highlighter-rouge">Templating</code>.</p> <p>The first variable is <code class="highlighter-rouge">host</code> and this provide the option to select the node and drill down to its metrics. When cAdvisor sends metrics to InfluxDB, it also includes some tags, which we will use to filter the metrics. There is a tag named <code class="highlighter-rouge">machine</code> that shows the hostname of the cAdvisor instance. In this case, it will match the ID of the hosts in swarm. To get the values in the tag, we use <code class="highlighter-rouge">show tag values with key = "machine"</code> as the query.</p> <p>The second variable is <code class="highlighter-rouge">container</code> and this is to further drill down to the container level metrics. There is a tag named <code class="highlighter-rouge">container_name</code> that contains the container name. We also need to only get the values based on the value of <code class="highlighter-rouge">host</code> variables. So, the query is <code class="highlighter-rouge">show tag values with key = "container_name" WHERE machine =~ /^$host$/</code>. This will fetch the containers which is running in the node selected by the <code class="highlighter-rouge">host</code> variable.</p> <p>The container name will look something like this, <code class="highlighter-rouge">monitor_cadvisor.y78ac29r904m8uy6hxffb7uvn.3j231njh03spl0j8h67z069cy</code>. However, we are only interested in <code class="highlighter-rouge">monitor_cadvisor</code> part of it, till the first period. If there are multiple instance of the same service, we need seperate lines. To filter the portion until first period, we use <code class="highlighter-rouge">/([^.]+)/</code> as the regex.</p> <p>Now that we have set up the varibles, we can use it in the graphs. We will discuss about <code class="highlighter-rouge">Memory</code> graph and the rest are similar. The memory values is present in the <code class="highlighter-rouge">memory_usage</code> series in InfluxDB, so the query starts with <code class="highlighter-rouge">SELECT "value" FROM "memory_usage"</code>.</p> <p>Now we add the filters with the <code class="highlighter-rouge">WHERE</code> keyword. The first condition is that <code class="highlighter-rouge">machine</code> is equal to <code class="highlighter-rouge">host</code> variable. That is given by <code class="highlighter-rouge">"machine" =~ /^$host$/</code>. The second condition is that <code class="highlighter-rouge">container_name</code> starts with the <code class="highlighter-rouge">container</code> variable. We use the <code class="highlighter-rouge">starts with</code> operator here because we have filtered the <code class="highlighter-rouge">container</code> variable until first period. This is given by <code class="highlighter-rouge">"container_name" =~ /^$container$*/</code>. The final condition is to match the time interval selected in grafana dashboard, <code class="highlighter-rouge">$timeFilter</code>. The query is now <code class="highlighter-rouge">SELECT "value" FROM "memory_usage" WHERE "container_name" =~ /^$container$*/ AND "machine" =~ /^$host$/ AND $timeFilter</code>.</p> <p>As we need seperate lines for different hosts and container, you need to group the data based on the <code class="highlighter-rouge">machine</code> and <code class="highlighter-rouge">container_name</code> tags. So now the entire query becomes, <code class="highlighter-rouge">SELECT "value" FROM "memory_usage" WHERE "container_name" =~ /^$container$*/ AND "machine" =~ /^$host$/ AND $timeFilter GROUP BY "machine", "container_name"</code>.</p> <p>We have also applied the alias for this query as <code class="highlighter-rouge">Memory {host: $tag_machine, container: $tag_container_name}</code>. Here, <code class="highlighter-rouge">$tag_machine</code> will be replaced by the value in <code class="highlighter-rouge">machine</code> tag and <code class="highlighter-rouge">tag_container_name</code> will be replaced by the value in <code class="highlighter-rouge">container_name</code> tag. The rest of the graphs are similar. Only the series name changes. You can also create alerts for these metrics from inside Grafana. For more about Alerting, check <a href="http://docs.grafana.org/alerting/rules/">here</a>.</p> <h2 id="conclusion">Conclusion</h2> <p>In this article, we were able to set up scalable monitoring solution for Docker Swarm, that automatically monitors all hosts and containers running in the swarm. While doing this, we became familiar with popular open-source tools like Grafana, InfluxDB and cAdvisor.</p> <p>Once you are done with the demonstration, you can remove the stack with command,</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker stack rm monitor</code></pre></figure> <p>If you are done with the VMs created for the demo, you can stop and remove then with the following commands,</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-machine stop manager agent1 agent2
docker-machine rm -f manager agent1 agent2</code></pre></figure> <p class="post-meta">Tags: docker, swarm, monitoring, cadvisor, influxdb, grafana, dashboard, alerting, docker-machine, swarmmode, and devops </p> </article> <article class="post-comments" id="comments-box"> <h1 class="page-title">Comments</h1> <form id="new-comment"> <input type="text" id="nameField" placeholder="Enter your name" required><br/> <textarea id="textField" placeholder="Your comments please." required></textarea><br/> <button type="submit" id="commentBtn">Post Comment</button> </form> <div id="comments"></div> </article> </section> <aside class="post-aside"> <div class ="aside" id="cat-list"> <h1 class="page-heading">Categories</h1> <a href="/categories/misc">Misc</a><br/> <a href="/categories/jekyll">Jekyll</a><br/> <a href="/categories/cloud">Cloud</a><br/> <a href="/categories/Node.js">Node.js</a><br/> <a href="/categories/javascript">Javascript</a><br/> <a href="/categories/devops">Devops</a><br/> </div> <div class ="aside"> <h1 class="page-heading">Related Stories</h1> <a href=/stories/log-management-of-docker-swarm-with-elk-stack/>Log Management for Docker Swarm with ELK Stack</a><br/><a href=/stories/blue-green-deployment-with-docker/>Building Blue-Green Deployment with Docker</a><br/><a href=/stories/auto-scaling-with-docker/>Auto Scaling with Docker</a><br/><a href=/stories/load-balancing-with-docker-swarm/>Load Balancing with Docker Swarm</a><br/><a href=/stories/setup-gitlab-for-docker-based-development/>Setup Gitlab for Docker based development</a><br/> </div> <p class="rss-subscribe">subscribe <a href="/feed">via RSS</a></p> <a href="#">Scroll to Top</a> </aside> </div> </div> </div> <footer class="site-footer"> <div class="footer-wrap"> <h2 class="footer-heading"><a href="/">botleg</a></h2> <div class="footer-col-wrapper"> <div class="footer-col footer-col-1"> <ul class="contact-list"> <li>By Hanzel Jesheen</li> <li><a href="mailto:blog@botleg.com">blog@botleg.com</a></li> </ul> </div> <div class="footer-col footer-col-2"> <ul class="social-media-list"> <li> <a href="https://github.com/botleg"> <span class="footer-icon"> <svg viewBox="0 0 16 16" width="16px" height="16px"> <use xlink:href="/assets/images/sprites.svg#gh"></use> </svg> </span> <span class="username">github</span> </a> </li> <li class="username"> <span class="footer-icon"> <svg viewBox="0 0 24 24" width="16px" height="16px"> <use xlink:href="/assets/images/sprites.svg#rss"></use> </svg> </span> subscribe <a href="/feed">via RSS</a> </li> </ul> </div> <div class="footer-col footer-col-3"> <p>Hi, botleg is a blog where you can find tutorials and techniques in web development, devops, databases, cloud computing and anything related to technology.</p> </div> </div> </div> </footer> <style type="text/css">body,h1,h2{font-weight:300}.wrapper:after{clear:both}html{box-sizing:border-box}body{background-color:#fdfdfd;color:#111;font-family:Helvetica,Arial,sans-serif;font-size:18px;line-height:1.6;}.wrapper section{margin-top:30px}a{color:#2a7ae2;text-decoration:none}.site-header{min-height:60px;position:relative}.site-title{margin-bottom:0;float:left;font-size:28px;line-height:60px;text-transform:lowercase;color:#e8e8e8}.post-header{box-align:center;justify-content:center;color:#fdfdfd;display:flex;height:300px;margin-bottom:10px}.rss-icon,#searchbox{display:none;}.post-header .header-content{text-align:center;max-width:600px}.icon{background-position:10px center;background-repeat:no-repeat;background-size:30px;padding:0 30px 0 45px}.icon span{color:#fdfdfd;display:none}@media screen and (min-width:400px){.icon span{display:inline}}.post-title{color:#e8e8e8;font-size:36px}.page-content,.post-content{margin-bottom:20px}.page-content h2,.post-content h2{font-size:32px}</style> <script> var cb = function() { var l = document.createElement('link'); l.rel = 'stylesheet'; l.href = '/assets/main.css?v310'; var h = document.getElementsByTagName('head')[0]; h.parentNode.insertBefore(l, h); }; var raf = requestAnimationFrame || mozRequestAnimationFrame || webkitRequestAnimationFrame || msRequestAnimationFrame; if (raf) raf(cb); else window.addEventListener('load', cb); </script> <script async type="text/javascript" src="/assets/js/post.js"></script> </body> </html>
