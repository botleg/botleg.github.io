<!DOCTYPE html> <html> <head> <title>Load Balancing with Docker Swarm - botleg</title> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="description" content=" Docker Swarm is native clustering for Docker. It turns a pool of Docker hosts into a single, virtual Docker host."> <meta name="author" content="Hanzel Jesheen"> <meta name="twitter:card" content="Docker Swarm lets us group a number of hosts into a cluster and distribute the docker images among these hosts. We will deploy a load balancer that will distribute the traffic to different instances of the docker images in the swarm." /> <meta name="twitter:site" content="@HanzelJesheen" /> <meta name="twitter:creator" content="@HanzelJesheen" /> <meta property="og:url" content="https://botleg.com/stories/load-balancing-with-docker-swarm/" /> <meta property="og:type" content="article" /> <meta property="og:title" content="Load Balancing with Docker Swarm" /> <meta property="og:description" content="Docker Swarm lets us group a number of hosts into a cluster and distribute the docker images among these hosts. We will deploy a load balancer that will distribute the traffic to different instances of the docker images in the swarm." /> <meta property="og:image" content="" /> <meta property="og:site_name" content="botleg" /> <meta property="article:author" content="Hanzel Jesheen" /> <meta itemprop="name" content="Load Balancing with Docker Swarm"> <meta itemprop="description" content=" Docker Swarm is native clustering for Docker. It turns a pool of Docker hosts into a single, virtual Docker host."> <link rel="canonical" href="https://botleg.com/stories/load-balancing-with-docker-swarm/"> <link rel="alternate" type="application/rss+xml" title="botleg" href="https://botleg.com/feed" /> </head> <body> <div class="page-content"> <div class="post"> <header style="background:rgb(11, 121, 194);background-image:linear-gradient(90deg, rgb(11, 121, 194) 25%, rgb(39, 174, 96) 100%);background-image:-moz-linear-gradient(left, rgb(11, 121, 194) 25%, rgb(39, 174, 96) 100%);background-image:-webkit-linear-gradient(left, rgb(11, 121, 194) 25%, rgb(39, 174, 96) 100%);background-image:-o-linear-gradient(left, rgb(11, 121, 194) 25%, rgb(39, 174, 96) 100%);background-image:-ms-linear-gradient(left, rgb(11, 121, 194) 25%, rgb(39, 174, 96) 100%);"> <section class="site-header"> <div class="wrapper"> <a class="site-title" href="/">Botleg</a> <div id="search"> <a href="/feed/index.xml"><span class="rss-icon"> <svg viewBox="0 0 24 24" width="30px" height="30px"> <use xlink:href="/assets/images/sprites.svg#rss"></use> </svg></span> </a> <form id="searchform"> <input type="text" placeholder="search" id="searchbox"> </form> </div> </div> </section> <section class="post-header"> <div class="header-content"> <h1 class="post-title">Load Balancing with Docker Swarm</h1> <a class="icon gh" href="https://github.com/botleg/load-balancing-swarm" target="blank"><span>View Code</span></a> </div> </section> </header> <div class="wrapper"> <section> <article class="post-content"> <p class="post-meta">Written by Hanzel Jesheen on Mar 8, 2016 | <a href="/categories/devops">devops</a> </p> <blockquote> <p>Docker Swarm is native clustering for Docker. It turns a pool of Docker hosts into a single, virtual Docker host.</p> </blockquote> <p>Docker Swarm lets us group a number of hosts into a cluster and distribute the docker images among these hosts. So, the workload in divided by the nodes in the swarm. In this article, we are going to deploy and scale an application. We will also deploy a load balancer that will distribute the traffic to different instances of the docker images in the swarm. You can follow along this article with only your terminal.</p> <p>In my <a href="/stories/orchestrate-docker-containers-with-tutum/">previous article</a>, we discussed load balancing with a docker orchestration tool, <a href="https://cloud.docker.com/">Docker Cloud</a> (previously known as <a href="https://www.tutum.co/">Tutum</a>). Now, we do the same thing with Docker Swarm. The docker image for load balancer is <a href="https://hub.docker.com/r/hanzel/load-balancing-swarm/">hanzel/load-balancing-swarm</a> and its code can be found <a href="https://github.com/botleg/load-balancing-swarm">here</a>. We are load balancing a Node.js application with Redis as the database. Also, the docker image for the Node.js application is <a href="https://hub.docker.com/r/hanzel/tutum-nodejs-redis/">hanzel/tutum-nodejs-redis</a> and its code can be found <a href="https://github.com/botleg/tutum-nodejs-redis">here</a>. For Redis, we use its official docker image - <a href="https://hub.docker.com/_/redis/">redis</a>.</p> <h2 id="prerequisites">Prerequisites</h2> <p>We will be using <a href="https://docs.docker.com/machine/">Docker Machine</a> to create and manage remote hosts as a swarm. With Docker Machine, you can create hosts on your local machine or your cloud provider. Check <a href="https://docs.docker.com/machine/drivers/">this link</a> to see the drivers supported by Docker Machine.</p> <p>You need to have the following installed in you local computer:</p> <ul> <li><code class="highlighter-rouge">Docker</code>: version &gt;= 1.10, to support Docker Compose File version 2 and Multi-Host networking.</li> <li><code class="highlighter-rouge">Docker Machine</code>: version &gt;= 0.6</li> <li><code class="highlighter-rouge">Docker Compose</code>: version &gt;= 1.6, to support Docker Compose file version 2</li> </ul> <p>You can create the virtual hosts in you local system if you have <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> installed. For this demonstration, I will be using <a href="https://docs.docker.com/machine/">DigitalOcean</a>.</p> <h2 id="initial-setup">Initial Setup</h2> <p>Before we start using Docker Machine, we need to setup some environment variables. You can see more about these environment variables from <a href="https://docs.docker.com/machine/drivers/">here</a>. Create a Personal Access Token from DigitalOcean. If you need help for that, check <a href="https://www.digitalocean.com/community/tutorials/how-to-use-the-digitalocean-api-v2#how-to-generate-a-personal-access-token">this</a> out. Your token will look something like <code class="highlighter-rouge">ed1d3d280778fe0e86b7a3e0fea065cf799fce3e575c722458897354e59de0b0</code>.</p> <p>We will use <code class="highlighter-rouge">Debian 8</code> as ths OS of the nodes and enable private networking, so that the hosts in the swarm can communicate with each other. Set these environment variables with the following bash commands.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">export </span><span class="nv">DIGITALOCEAN_ACCESS_TOKEN</span><span class="o">=</span>YOUR_DIGITALOCEAN_TOKEN
<span class="nb">export </span><span class="nv">DIGITALOCEAN_PRIVATE_NETWORKING</span><span class="o">=</span><span class="nb">true
export </span><span class="nv">DIGITALOCEAN_IMAGE</span><span class="o">=</span>debian-8-x64</code></pre></figure> <h2 id="consul">Consul</h2> <p>To create a Swarm, we need access to a Key-Value store for service discovery and to store configuration. Swarm supports Consul, Etcd, and ZooKeeper. We will be using <a href="https://www.consul.io/">Consul</a>.</p> <p>We will be creating a host for running Consul alone. It will not be a part of the swarm. So we can create a host named <code class="highlighter-rouge">consul</code> first.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-machine create <span class="se">\</span>
  -d digitalocean <span class="se">\</span>
  consul</code></pre></figure> <p>This command will create a host in DigitalOcean and provision it. You can use the command <code class="highlighter-rouge">docker-machine ssh consul</code>, to ssh into this host. We will store the private IP of this host as <code class="highlighter-rouge">KV_IP</code> environment variable with the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">export </span><span class="nv">KV_IP</span><span class="o">=</span><span class="k">$(</span>docker-machine ssh consul <span class="s1">'ifconfig eth1 | grep "inet addr:" | cut -d: -f2 | cut -d" " -f1'</span><span class="k">)</span></code></pre></figure> <p>We need to connect out docker client to this host and then run <a href="https://hub.docker.com/r/progrium/consul/">progrium/consul</a> image there.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">eval</span> <span class="k">$(</span>docker-machine env consul<span class="k">)</span>

docker run -d <span class="se">\</span>
  -p <span class="k">${</span><span class="nv">KV_IP</span><span class="k">}</span>:8500:8500 <span class="se">\</span>
  -h consul <span class="se">\</span>
  --restart always <span class="se">\</span>
  gliderlabs/consul-server -bootstrap</code></pre></figure> <p>This command will pull and deploy the image in <code class="highlighter-rouge">consul</code> host.</p> <h2 id="the-swarm">The Swarm</h2> <p>Now, we will create the swarm. A Docker swarm need a master node and an arbitrary number of ordinary nodes. The swarm master is named <code class="highlighter-rouge">master</code> and we will create this now.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-machine create <span class="se">\</span>
  -d digitalocean <span class="se">\</span>
  --swarm <span class="se">\</span>
  --swarm-master <span class="se">\</span>
  --swarm-discovery<span class="o">=</span><span class="s2">"consul://</span><span class="k">${</span><span class="nv">KV_IP</span><span class="k">}</span><span class="s2">:8500"</span> <span class="se">\</span>
  --engine-opt<span class="o">=</span><span class="s2">"cluster-store=consul://</span><span class="k">${</span><span class="nv">KV_IP</span><span class="k">}</span><span class="s2">:8500"</span> <span class="se">\</span>
  --engine-opt<span class="o">=</span><span class="s2">"cluster-advertise=eth1:2376"</span> <span class="se">\</span>
  master</code></pre></figure> <p>The <code class="highlighter-rouge">swarm-master</code> flag idetifies this node as the swarm master. We also need to provide the consul endpoint as the <code class="highlighter-rouge">swarm-discovery</code> flag. For us, this is <code class="highlighter-rouge">consul://${KV_IP}:8500</code>. We will set the private IP for this host as <code class="highlighter-rouge">MASTER_IP</code>.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">export </span><span class="nv">MASTER_IP</span><span class="o">=</span><span class="k">$(</span>docker-machine ssh master <span class="s1">'ifconfig eth1 | grep "inet addr:" | cut -d: -f2 | cut -d" " -f1'</span><span class="k">)</span></code></pre></figure> <p>We can now create any number of nodes in this swarm. For this example, we will have only one other node in the swarm and it is named <code class="highlighter-rouge">slave</code>. We will create this host and set its private IP as <code class="highlighter-rouge">SLAVE_IP</code> with the following commands.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-machine create <span class="se">\</span>
  -d digitalocean <span class="se">\</span>
  --swarm <span class="se">\</span>
  --swarm-discovery<span class="o">=</span><span class="s2">"consul://</span><span class="k">${</span><span class="nv">KV_IP</span><span class="k">}</span><span class="s2">:8500"</span> <span class="se">\</span>
  --engine-opt<span class="o">=</span><span class="s2">"cluster-store=consul://</span><span class="k">${</span><span class="nv">KV_IP</span><span class="k">}</span><span class="s2">:8500"</span> <span class="se">\</span>
  --engine-opt<span class="o">=</span><span class="s2">"cluster-advertise=eth1:2376"</span> <span class="se">\</span>
  slave

<span class="nb">export </span><span class="nv">SLAVE_IP</span><span class="o">=</span><span class="k">$(</span>docker-machine ssh slave <span class="s1">'ifconfig eth1 | grep "inet addr:" | cut -d: -f2 | cut -d" " -f1'</span><span class="k">)</span></code></pre></figure> <p>You can create more nodes in the swarm by repeating these commands by just changing the hostname. We also need to have a registrator service running in each of these hosts to keep track of all services running in each host. The version 6 of <code class="highlighter-rouge">gliderlabs/registrator</code> image is used for this.</p> <p>We need to connect our client to each of these hosts and run the registrator image.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">eval</span> <span class="k">$(</span>docker-machine env master<span class="k">)</span>

docker run -d <span class="se">\</span>
  --name<span class="o">=</span>registrator <span class="se">\</span>
  -h <span class="k">${</span><span class="nv">MASTER_IP</span><span class="k">}</span> <span class="se">\</span>
  --volume<span class="o">=</span>/var/run/docker.sock:/tmp/docker.sock <span class="se">\</span>
  gliderlabs/registrator:v6 <span class="se">\</span>
  consul://<span class="k">${</span><span class="nv">KV_IP</span><span class="k">}</span>:8500

<span class="nb">eval</span> <span class="k">$(</span>docker-machine env slave<span class="k">)</span>

docker run -d <span class="se">\</span>
  --name<span class="o">=</span>registrator <span class="se">\</span>
  -h <span class="k">${</span><span class="nv">SLAVE_IP</span><span class="k">}</span> <span class="se">\</span>
  --volume<span class="o">=</span>/var/run/docker.sock:/tmp/docker.sock <span class="se">\</span>
  gliderlabs/registrator:v6 <span class="se">\</span>
  consul://<span class="k">${</span><span class="nv">KV_IP</span><span class="k">}</span>:8500</code></pre></figure> <p>This service will keep track of the information like IP and PORT of each service running in the host and saves it to consul. We can now connect the docker client to the swarm. For this, we use <code class="highlighter-rouge">-swarm</code> parameter with the swarm master.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">eval</span> <span class="k">$(</span>docker-machine env -swarm master<span class="k">)</span></code></pre></figure> <p>We can see all the hosts created with <code class="highlighter-rouge">docker-machine</code> with the command <code class="highlighter-rouge">docker-machine ls</code>. The output of this command must look something like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">NAME     ACTIVE      DRIVER         STATE     URL                          SWARM             DOCKER
consul   -           digitalocean   Running   tcp://104.131.126.139:2376                     v1.10.1
master   <span class="k">*</span> <span class="o">(</span>swarm<span class="o">)</span>   digitalocean   Running   tcp://45.55.48.84:2376       master <span class="o">(</span>master<span class="o">)</span>   v1.10.1
slave    -           digitalocean   Running   tcp://104.131.177.65:2376    master            v1.10.1 </code></pre></figure> <h2 id="docker-compose">Docker Compose</h2> <p>We have set up the swarm, it is ready for deployment. For this demonstration, we will be deploying multiple instances of Node.js application with a single instance of Redis as the database. The code for this Node.js application can be found <a href="https://github.com/botleg/tutum-nodejs-redis">here</a>. It just lets us set the read values from redis. The docker images used for this is <a href="https://hub.docker.com/r/hanzel/tutum-nodejs-redis/">hanzel/tutum-nodejs-redis</a>.</p> <p>Docker Compose allows us to write the configuration file for this deployment. We are going to use the Docker Compose File version 2, which allows us to define configuration about the network and volumes used for the deployment in <code class="highlighter-rouge">docker-compose.yml</code> file. You can know more about Version 2 of compose file <a href="https://docs.docker.com/compose/compose-file/#version-2">here</a>.</p> <p>The <code class="highlighter-rouge">docker-compose.yml</code> file looks like this.</p> <figure class="highlight"><pre><code class="language-conf" data-lang="conf"><span class="n">version</span>: <span class="s1">'2'</span>

<span class="n">services</span>:
  <span class="n">web</span>:
    <span class="n">image</span>: <span class="n">hanzel</span>/<span class="n">tutum</span>-<span class="n">nodejs</span>-<span class="n">redis</span>
    <span class="n">ports</span>:
      - <span class="s2">"4000"</span>
    <span class="n">environment</span>:
      - <span class="n">APP_PORT</span>=<span class="m">4000</span>
      - <span class="n">REDIS_IP</span>=<span class="n">redis</span>
      - <span class="n">REDIS_PORT</span>=<span class="m">6379</span>
    <span class="n">depends_on</span>:
      - <span class="n">redis</span>
    <span class="n">networks</span>:
      - <span class="n">back</span>-<span class="n">tier</span>

  <span class="n">redis</span>:
    <span class="n">image</span>: <span class="n">redis</span>
    <span class="n">container_name</span>: <span class="n">redis</span>
    <span class="n">command</span>: <span class="n">redis</span>-<span class="n">server</span> --<span class="n">appendonly</span> <span class="n">yes</span>
    <span class="n">volumes</span>:
      - <span class="n">redis</span>-<span class="n">data</span>:/<span class="n">data</span>
    <span class="n">networks</span>:
      - <span class="n">back</span>-<span class="n">tier</span>

<span class="n">volumes</span>:
  <span class="n">redis</span>-<span class="n">data</span>:
    <span class="n">driver</span>: <span class="n">local</span>

<span class="n">networks</span>:
  <span class="n">back</span>-<span class="n">tier</span>:
    <span class="n">driver</span>: <span class="n">overlay</span></code></pre></figure> <p>The first service is <code class="highlighter-rouge">web</code> and it contains the image <code class="highlighter-rouge">hanzel/tutum-nodejs-redis</code>, which is the node.js application. We are pulishing the port 4000 inside the container. It will be mapped to some port of the host. We need to setup some environment variables:</p> <ul> <li><code class="highlighter-rouge">APP_PORT</code>: Port to run the Node.js application.</li> <li><code class="highlighter-rouge">REDIS_IP</code>: The IP of the redis instance.</li> <li><code class="highlighter-rouge">REDIS_PORT</code>: The PORT of the redis instance.</li> </ul> <p>The second service is the official <code class="highlighter-rouge">redis</code> image. For persistant data storage, we are creating a data volumes named <code class="highlighter-rouge">redis-data</code>. This volume is of the type <code class="highlighter-rouge">local</code>, so the data is stored in the local host system.</p> <p>The services in the same network are linked. Here, both these services are in the <code class="highlighter-rouge">back-tier</code> network which is of the type <code class="highlighter-rouge">overlay</code>. The overlay network allow <code class="highlighter-rouge">multi-host networking</code>, this allows the service to be linked even if the these are in different hosts.</p> <p>Save this code as <code class="highlighter-rouge">docker-compose.yml</code> and save it in a folder. Make sure that your docker client is connected to the swarm with <code class="highlighter-rouge">eval $(docker-machine env -swarm master)</code> command. Now open up the terminal in this folder and start the services using the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-compose up -d</code></pre></figure> <p>This will start up the services, which are distributed across the different hosts in the swarm. You can see details about the running services with the command <code class="highlighter-rouge">docker-compose ps</code>. The output must look something like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">Name                       Command                          State     Ports           
-------------------------------------------------------------------------------------------------
loadbalancingswarm_web_1   npm start                        Up        45.55.48.84:32768-&gt;4000/tcp
redis                      /entrypoint.sh redis-serve ...   Up        6379/tcp                   </code></pre></figure> <p>In this case, you can see the app running at <code class="highlighter-rouge">45.55.48.84:32768</code>.</p> <h2 id="load-balancer">Load Balancer</h2> <p>We have a single instance of the app running. We need to now implement a load balancer that can distribute the traffic across all the instances of this service. As we increase and decrease the instances of the service, we need to automatically update the load balancer. The code for the load balancer can be found <a href="https://github.com/botleg/load-balancing-swarm">here</a> and the docker image for this is <a href="https://hub.docker.com/r/hanzel/load-balancing-swarm/">hanzel/load-balancing-swarm</a>.</p> <p>We will use <a href="https://www.nginx.com/">nginx</a> for load balancing and <a href="https://github.com/hashicorp/consul-template">consul-template</a> to manage nginx configuration. You can also use HAproxy as the load balancer, the process is similar.</p> <p>First, we need to create a template file for nginx configuration. This file is filled with the service information by consul-template and forms the configuration for nginx. The file <code class="highlighter-rouge">default.ctmpl</code> looks like this.</p> <figure class="highlight"><pre><code class="language-conf" data-lang="conf">{{$<span class="n">app</span> := <span class="n">env</span> <span class="s2">"APP_NAME"</span>}}

<span class="n">upstream</span> {{<span class="n">printf</span> $<span class="n">app</span>}} {
    <span class="n">least_conn</span>;
    {{<span class="n">range</span> <span class="n">service</span> $<span class="n">app</span>}}
    <span class="n">server</span> {{.<span class="n">Address</span>}}:{{.<span class="n">Port</span>}} <span class="n">max_fails</span>=<span class="m">3</span> <span class="n">fail_timeout</span>=<span class="m">60</span> <span class="n">weight</span>=<span class="m">1</span>;{{<span class="n">end</span>}}
}

<span class="n">server</span> {
    <span class="n">listen</span> <span class="m">80</span> <span class="n">default</span>;

    <span class="n">location</span> / {
        <span class="n">proxy_pass</span> <span class="n">http</span>://{{<span class="n">printf</span> $<span class="n">app</span>}};
    }
}</code></pre></figure> <p>We will set variable <code class="highlighter-rouge">app</code> with the value of environment variable <code class="highlighter-rouge">APP_NAME</code>. We create a upstream named with the variable <code class="highlighter-rouge">app</code>. The <code class="highlighter-rouge">least_conn</code> line causes nginx is to route traffic to the least connected instance. We need to generate <code class="highlighter-rouge">server</code> configuration lines for each instance of the service currently running. This is done by the code block, <code class="highlighter-rouge"><span class="p">{</span><span class="err">{range</span><span class="w"> </span><span class="err">service</span><span class="w"> </span><span class="err">$app</span><span class="p">}</span><span class="err">}...</span><span class="p">{</span><span class="err">{end</span><span class="p">}</span><span class="err">}</span></code>. The code between these directives are repeated for each instance of the service running with <code class="highlighter-rouge"><span class="p">{</span><span class="err">{.Address</span><span class="p">}</span><span class="err">}</span></code> replaced by the address and <code class="highlighter-rouge"><span class="p">{</span><span class="err">{.Port</span><span class="p">}</span><span class="err">}</span></code> replaced by its port of that instance. Next we have the server block that is listening to the port 80. This will create a reverse proxy to the upstream we just created.</p> <p>We need a bash script, that acts as the entry point to this docker image. The file <code class="highlighter-rouge">start.sh</code> looks like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
service nginx start
consul-template -consul<span class="o">=</span><span class="nv">$CONSUL_URL</span> -template<span class="o">=</span><span class="s2">"/templates/default.ctmpl:/etc/nginx/conf.d/default.conf:service nginx reload"</span></code></pre></figure> <p>This script starts up nginx service. We then start up <code class="highlighter-rouge">consul-template</code>. This command need two parameter. The first one is <code class="highlighter-rouge">-consul</code> and it requires the url for consul. We pass an environment variable for this. The next one is called <code class="highlighter-rouge">-template</code> and it consists of three parts seperated by a colon. The first one is the path of the template file. The second is the path where the generated configuration file must be placed. The third is the command that must by run when new configuration is generated. Here, we need to reload nginx.</p> <p>The consul-template will create new configuration file whenever a service starts or stops. The information about this is collected by the registrator services running in each node is our swarm and is stored in consul.</p> <p>Save these two files in folder named <code class="highlighter-rouge">files</code> and in its parent, we can have the <code class="highlighter-rouge">Dockerfile</code> and <code class="highlighter-rouge">docker-compose.yml</code>. The <code class="highlighter-rouge">Dockerfile</code> contains information on how to build this docker image.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">FROM nginx:latest

RUN apt-get update <span class="se">\</span>
  <span class="o">&amp;&amp;</span> apt-get install -y unzip

ADD files/start.sh /bin/start.sh
RUN chmod +x /bin/start.sh
ADD files/default.ctmpl /templates/default.ctmpl

ADD https://releases.hashicorp.com/consul-template/0.12.2/consul-template_0.12.2_linux_amd64.zip /usr/bin/
RUN unzip /usr/bin/consul-template_0.12.2_linux_amd64.zip -d /usr/local/bin

EXPOSE 80
ENTRYPOINT <span class="o">[</span><span class="s2">"/bin/start.sh"</span><span class="o">]</span></code></pre></figure> <p>This dockerfile uses <code class="highlighter-rouge">nginx</code> as the base and installs consul-template into it. It then copies the <code class="highlighter-rouge">start.sh</code> and <code class="highlighter-rouge">default.ctmpl</code> to required location. Finally, it exposes the port 80 and sets <code class="highlighter-rouge">start.sh</code> as the entry point of the image.</p> <h2 id="new-compose-file">New Compose file</h2> <p>Create the file <code class="highlighter-rouge">docker-compose.yml</code> in the folder containing Dockerfile. We can now add this service to this file. So, the new compose file will look like this.</p> <figure class="highlight"><pre><code class="language-conf" data-lang="conf"><span class="n">version</span>: <span class="s1">'2'</span>

<span class="n">services</span>:
  <span class="n">lb</span>:
    <span class="n">build</span>: .
    <span class="n">container_name</span>: <span class="n">lb</span>
    <span class="n">ports</span>:
      - <span class="s2">"80:80"</span>
    <span class="n">environment</span>:
      - <span class="n">constraint</span>:<span class="n">node</span>==<span class="n">master</span>
      - <span class="n">APP_NAME</span>=<span class="n">tutum</span>-<span class="n">nodejs</span>-<span class="n">redis</span>
      - <span class="n">CONSUL_URL</span>=${<span class="n">KV_IP</span>}:<span class="m">8500</span>
    <span class="n">depends_on</span>:
      - <span class="n">web</span>
    <span class="n">networks</span>:
      - <span class="n">front</span>-<span class="n">tier</span>

  <span class="n">web</span>:
    <span class="n">image</span>: <span class="n">hanzel</span>/<span class="n">tutum</span>-<span class="n">nodejs</span>-<span class="n">redis</span>
    <span class="n">ports</span>:
      - <span class="s2">"4000"</span>
    <span class="n">environment</span>:
      - <span class="n">APP_PORT</span>=<span class="m">4000</span>
      - <span class="n">REDIS_IP</span>=<span class="n">redis</span>
      - <span class="n">REDIS_PORT</span>=<span class="m">6379</span>
    <span class="n">depends_on</span>:
      - <span class="n">redis</span>
    <span class="n">networks</span>:
      - <span class="n">front</span>-<span class="n">tier</span>
      - <span class="n">back</span>-<span class="n">tier</span>

  <span class="n">redis</span>:
    <span class="n">image</span>: <span class="n">redis</span>
    <span class="n">container_name</span>: <span class="n">redis</span>
    <span class="n">command</span>: <span class="n">redis</span>-<span class="n">server</span> --<span class="n">appendonly</span> <span class="n">yes</span>
    <span class="n">volumes</span>:
      - <span class="n">redis</span>-<span class="n">data</span>:/<span class="n">data</span>
    <span class="n">networks</span>:
      - <span class="n">back</span>-<span class="n">tier</span>

<span class="n">volumes</span>:
  <span class="n">redis</span>-<span class="n">data</span>:
    <span class="n">driver</span>: <span class="n">local</span>

<span class="n">networks</span>:
  <span class="n">front</span>-<span class="n">tier</span>:
    <span class="n">driver</span>: <span class="n">overlay</span>
  <span class="n">back</span>-<span class="n">tier</span>:
    <span class="n">driver</span>: <span class="n">overlay</span></code></pre></figure> <p>We have new service name <code class="highlighter-rouge">lb</code>. It is build using Dockerfile in the current directory. The port 80 of the container is mapped to port 80 of the host. We need to set up three environment variables:</p> <ul> <li><code class="highlighter-rouge">constraint:node</code>: The name of the node where this service should run. We want the load balancing to always run on the <code class="highlighter-rouge">master</code> node.</li> <li><code class="highlighter-rouge">APP_NAME</code>: The image name of the service you need to load balance. Here, it is <code class="highlighter-rouge">tutum-nodejs-redis</code>. You can load balance any service by providing its name here.</li> <li><code class="highlighter-rouge">CONSUL_URL</code>: The url of consul. We are using the <code class="highlighter-rouge">KV_IP</code> environment variable for this.</li> </ul> <p>We have a new overlay network named <code class="highlighter-rouge">front-tier</code>. This connects <code class="highlighter-rouge">lb</code> and <code class="highlighter-rouge">web</code> services. Note that, the load balancer doesn’t need to connect to redis, so these are put in two different networks. The <code class="highlighter-rouge">web</code> services is connected to both these networks.</p> <p>Instead of building a new image, you may use the image <a href="https://hub.docker.com/r/hanzel/load-balancing-swarm/">hanzel/load-balancing-swarm</a>. Just replace the line <code class="highlighter-rouge">build: .</code> with <code class="highlighter-rouge">image: hanzel/load-balancing-swarm</code>.</p> <p>Now we need to stop and remove the running services and start the new services.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-compose stop; docker-compose rm -f
docker-compose up -d</code></pre></figure> <p>We have only one instance of <code class="highlighter-rouge">web</code> running now. We will scale this to three with the following command.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-compose scale <span class="nv">web</span><span class="o">=</span>3</code></pre></figure> <p>We can see that three instances of the <code class="highlighter-rouge">web</code> service is running when we do <code class="highlighter-rouge">docker-compose ps</code>. The output will look like this.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">Name                       Command                          State   Ports               
------------------------------------------------------------------------------------------------------
lb                         /bin/start.sh                    Up      443/tcp, 104.131.177.65:80-&gt;80/tcp
loadbalancingswarm_web_1   npm start                        Up      45.55.48.84:32777-&gt;4000/tcp
loadbalancingswarm_web_2   npm start                        Up      104.131.177.65:32772-&gt;4000/tcp
loadbalancingswarm_web_3   npm start                        Up      45.55.48.84:32778-&gt;4000/tcp
redis                      /entrypoint.sh redis-serve ...   Up      6379/tcp</code></pre></figure> <p>In this case, you can go to <code class="highlighter-rouge">104.131.177.65</code>, the IP of your master node to see the application running. Refresh the page and see the <code class="highlighter-rouge">host</code> value changing. This shows that the load balancer is working.</p> <p>You can see the nginx configuration generated by consul-template by using the command <code class="highlighter-rouge">docker exec -t lb cat /etc/nginx/conf.d/default.conf</code>. This should produce an output that looks like this.</p> <figure class="highlight"><pre><code class="language-nginx" data-lang="nginx"><span class="k">upstream</span> <span class="s">tutum-nodejs-redis</span> <span class="p">{</span>
  <span class="kn">least_conn</span><span class="p">;</span>

  <span class="kn">server</span> <span class="nf">10.132.1.191</span><span class="p">:</span><span class="mi">32777</span> <span class="s">max_fails=3</span> <span class="s">fail_timeout=60</span> <span class="s">weight=1</span><span class="p">;</span>
  <span class="kn">server</span> <span class="nf">10.132.1.191</span><span class="p">:</span><span class="mi">32778</span> <span class="s">max_fails=3</span> <span class="s">fail_timeout=60</span> <span class="s">weight=1</span><span class="p">;</span>
  <span class="kn">server</span> <span class="nf">10.132.14.17</span><span class="p">:</span><span class="mi">32772</span> <span class="s">max_fails=3</span> <span class="s">fail_timeout=60</span> <span class="s">weight=1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">server</span> <span class="p">{</span>
  <span class="kn">listen</span> <span class="mi">80</span> <span class="s">default</span><span class="p">;</span>

  <span class="kn">location</span> <span class="n">/</span> <span class="p">{</span>
    <span class="kn">proxy_pass</span> <span class="s">http://tutum-nodejs-redis</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure> <h2 id="conclusion">Conclusion</h2> <p>Docker Swarm allows us to seamlessly scale and distribute docker work load to a cluster of hosts. We have now implemented load balancing of docker images using Docker Swarm. This is just a basic application of docker swarm. You can create more sophisticated setups with docker swarm like auto-scaling, database cluster, etc. I will try talking more about that in the coming articles.</p> <p>You can stop the services and remove the hosts using the following commands.</p> <figure class="highlight"><pre><code class="language-bash" data-lang="bash">docker-compose down
docker-machine stop consul master slave
docker-machine rm consul master slave</code></pre></figure> <p class="post-meta">Tags: docker, swarm, cluster, nodejs, redis, nginx, consul, consul-template, multi-host, networking, overlay, digitalocean, compose, machine, and devops </p> </article> <article class="post-comments" id="comments-box"> <h1 class="page-title">Comments</h1> <form id="new-comment"> <input type="text" id="nameField" placeholder="Enter your name" required><br/> <textarea id="textField" placeholder="Your comments please." required></textarea><br/> <button type="submit" id="commentBtn">Post Comment</button> </form> <div id="comments"></div> </article> </section> <aside class="post-aside"> <div class ="aside" id="cat-list"> <h1 class="page-heading">Categories</h1> <a href="/categories/misc">Misc</a><br/> <a href="/categories/jekyll">Jekyll</a><br/> <a href="/categories/cloud">Cloud</a><br/> <a href="/categories/Node.js">Node.js</a><br/> <a href="/categories/javascript">Javascript</a><br/> <a href="/categories/devops">Devops</a><br/> <a href="/categories/crypto">Crypto</a><br/> </div> <div class ="aside"> <h1 class="page-heading">Related Stories</h1> <a href=/stories/blue-green-deployment-with-docker/>Building Blue-Green Deployment with Docker</a><br/><a href=/stories/auto-scaling-with-docker/>Auto Scaling with Docker</a><br/><a href=/stories/setup-gitlab-for-docker-based-development/>Setup Gitlab for Docker based development</a><br/><a href=/stories/docker-hosting-with-sloppyio/>Docker Hosting with sloppy.io</a><br/><a href=/stories/monitoring-docker-swarm-with-cadvisor-influxdb-and-grafana/>Monitoring Docker Swarm with cAdvisor, InfluxDB and Grafana</a><br/> </div> <p class="rss-subscribe">subscribe <a href="/feed">via RSS</a></p> <a href="#">Scroll to Top</a> </aside> </div> </div> </div> <footer class="site-footer"> <div class="footer-wrap"> <h2 class="footer-heading"><a href="/">botleg</a></h2> <div class="footer-col-wrapper"> <div class="footer-col footer-col-1"> <ul class="contact-list"> <li>By Hanzel Jesheen</li> <li><a href="mailto:blog@botleg.com">blog@botleg.com</a></li> </ul> </div> <div class="footer-col footer-col-2"> <ul class="social-media-list"> <li> <a href="https://github.com/botleg"> <span class="footer-icon"> <svg viewBox="0 0 16 16" width="16px" height="16px"> <use xlink:href="/assets/images/sprites.svg#gh"></use> </svg> </span> <span class="username">github</span> </a> </li> <li class="username"> <span class="footer-icon"> <svg viewBox="0 0 24 24" width="16px" height="16px"> <use xlink:href="/assets/images/sprites.svg#rss"></use> </svg> </span> subscribe <a href="/feed">via RSS</a> </li> </ul> </div> <div class="footer-col footer-col-3"> <p>Hi, botleg is a blog where you can find tutorials and techniques in web development, devops, databases, cloud computing and anything related to technology.</p> </div> </div> </div> </footer> <style type="text/css">body,h1,h2{font-weight:300}.wrapper:after{clear:both}html{box-sizing:border-box}body{background-color:#fdfdfd;color:#111;font-family:Helvetica,Arial,sans-serif;font-size:18px;line-height:1.6;}.wrapper section{margin-top:30px}a{color:#2a7ae2;text-decoration:none}.site-header{min-height:60px;position:relative}.site-title{margin-bottom:0;float:left;font-size:28px;line-height:60px;text-transform:lowercase;color:#e8e8e8}.post-header{box-align:center;justify-content:center;color:#fdfdfd;display:flex;height:300px;margin-bottom:10px}.rss-icon,#searchbox{display:none;}.post-header .header-content{text-align:center;max-width:600px}.icon{background-position:10px center;background-repeat:no-repeat;background-size:30px;padding:0 30px 0 45px}.icon span{color:#fdfdfd;display:none}@media screen and (min-width:400px){.icon span{display:inline}}.post-title{color:#e8e8e8;font-size:36px}.page-content,.post-content{margin-bottom:20px}.page-content h2,.post-content h2{font-size:32px}</style> <script> var cb = function() { var l = document.createElement('link'); l.rel = 'stylesheet'; l.href = '/assets/main.css?v310'; var h = document.getElementsByTagName('head')[0]; h.parentNode.insertBefore(l, h); }; var raf = requestAnimationFrame || mozRequestAnimationFrame || webkitRequestAnimationFrame || msRequestAnimationFrame; if (raf) raf(cb); else window.addEventListener('load', cb); </script> <script async type="text/javascript" src="/assets/js/post.js"></script> </body> </html>
